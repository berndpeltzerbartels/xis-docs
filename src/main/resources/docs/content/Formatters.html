<xis:template xmlns:xis="http://www.w3.org/1999/XSL/Transform">
    <h3>${chapterHeadline}</h3>
    <p>Formatters enable bidirectional conversion between string representations and Java objects. They work in both 
        directions: parsing form input to Java types and formatting Java objects for template display.</p>

    <h5>Why Formatters?</h5>
    <p>Formatters solve the problem of locale-specific and business-specific data representation:</p>
    <xis:raw>
        <ul>
            <li><strong>Locale-specific display:</strong> Show "1.234,56 €" in Germany, "$1,234.56" in the US</li>
            <li><strong>Business objects:</strong> Convert complex types like Money, Measurement, Coordinates</li>
            <li><strong>Consistent formatting:</strong> Same format rules in forms and display templates</li>
            <li><strong>Type safety:</strong> Work with proper Java types instead of strings</li>
        </ul>
    </xis:raw>

    <h5>Built-in Type Conversion</h5>
    <p>XIS automatically converts these types without additional configuration:</p>
    <xis:raw>
        <ul>
            <li><strong>Primitives:</strong> int, long, double, float, boolean</li>
            <li><strong>Wrapper Types:</strong> Integer, Long, Double, Float, Boolean</li>
            <li><strong>String:</strong> No conversion needed</li>
            <li><strong>Enums:</strong> By name (case-insensitive)</li>
            <li><strong>BigDecimal / BigInteger:</strong> From numeric strings</li>
        </ul>
    </xis:raw>

    <h5>The Formatter Interface</h5>
    <p>All formatters implement the <code>Formatter&lt;T&gt;</code> interface:</p>
    <xis:raw>
        <pre><code>import one.xis.Formatter;
import java.time.ZoneId;
import java.util.Locale;

public interface Formatter&lt;T&gt; {
    String format(T value, Locale locale, ZoneId zoneId);
    T parse(String text, Locale locale, ZoneId zoneId);
}</code></pre>
        <p>The interface provides locale and timezone information for context-aware formatting.</p>
    </xis:raw>

    <h5>Example: Money Formatting</h5>
    <p>A typical use case is locale-aware money formatting:</p>
    <xis:raw>
        <pre><code>import one.xis.Formatter;
import java.math.BigDecimal;
import java.text.NumberFormat;
import java.time.ZoneId;
import java.util.Locale;

public class MoneyFormatter implements Formatter&lt;BigDecimal&gt; {
    
    @Override
    public String format(BigDecimal value, Locale locale, ZoneId zoneId) {
        // BigDecimal → "1.234,56 €" (Germany) or "$1,234.56" (US)
        NumberFormat format = NumberFormat.getCurrencyInstance(locale);
        return format.format(value);
    }
    
    @Override
    public BigDecimal parse(String value, Locale locale, ZoneId zoneId) {
        // "1.234,56 €" → BigDecimal
        String cleaned = value.replaceAll("[^0-9,.-]", "");
        if (locale.getLanguage().equals("de")) {
            cleaned = cleaned.replace(".", "").replace(",", ".");
        } else {
            cleaned = cleaned.replace(",", "");
        }
        return new BigDecimal(cleaned);
    }
}

// In form or page class
@FormData("product")
ProductForm productForm;

public class ProductForm {
    @UseFormatter(MoneyFormatter.class)
    private BigDecimal price;
}</code></pre>
        <p><strong>Template (Form):</strong></p>
        <pre><code>&lt;input type="text" name="product.price" value="${product.price}"/&gt;
&lt;!-- Displays: "1.234,56 €", User can edit, parses back to BigDecimal --&gt;</code></pre>
        <p><strong>Template (Display):</strong></p>
        <pre><code>&lt;span&gt;Price: ${product.price}&lt;/span&gt;
&lt;!-- Shows: "Price: 1.234,56 €" --&gt;</code></pre>
    </xis:raw>

    <h5>Example: Percentage Formatting</h5>
    <p>Format percentages with locale-specific patterns:</p>
    <xis:raw>
        <pre><code>public class PercentageFormatter implements Formatter&lt;BigDecimal&gt; {
    
    @Override
    public String format(BigDecimal value, Locale locale, ZoneId zoneId) {
        // 0.755 → "75,5 %" (Germany) or "75.5%" (US)
        BigDecimal percentage = value.multiply(new BigDecimal("100"));
        NumberFormat format = NumberFormat.getPercentInstance(locale);
        format.setMaximumFractionDigits(1);
        return format.format(value);
    }
    
    @Override
    public BigDecimal parse(String value, Locale locale, ZoneId zoneId) {
        // "75,5 %" → 0.755 (BigDecimal)
        String cleaned = value.replace("%", "").trim();
        if (locale.getLanguage().equals("de")) {
            cleaned = cleaned.replace(",", ".");
        }
        return new BigDecimal(cleaned).divide(new BigDecimal("100"));
    }
}

// In controller
@FormData("discount")
DiscountForm discountForm;

public class DiscountForm {
    @UseFormatter(PercentageFormatter.class)
    private BigDecimal rate;
}</code></pre>
    </xis:raw>

    <h5>Complex Business Objects</h5>
    <p>Formatters can handle complex domain objects:</p>
    <xis:raw>
        <pre><code>public class Coordinate {
    private double latitude;
    private double longitude;
    // constructor, getters
}

public class CoordinateFormatter implements Formatter&lt;Coordinate&gt; {
    
    @Override
    public String format(Coordinate value, Locale locale, ZoneId zoneId) {
        // Coordinate → "52.5200,13.4050"
        return String.format(Locale.US, "%.4f,%.4f", 
            value.getLatitude(), value.getLongitude());
    }
    
    @Override
    public Coordinate parse(String value, Locale locale, ZoneId zoneId) {
        // "52.5200,13.4050" → Coordinate
        String[] parts = value.split(",");
        double lat = Double.parseDouble(parts[0].trim());
        double lon = Double.parseDouble(parts[1].trim());
        return new Coordinate(lat, lon);
    }
}

// Usage
@UseFormatter(CoordinateFormatter.class)
private Coordinate location;</code></pre>
    </xis:raw>

    <h5>Using Formatters in Forms</h5>
    <p>Formatters automatically work in form bindings:</p>
    <xis:raw>
        <pre><code>@Widget
class ProductFormWidget {
    
    @FormData("product")
    ProductForm productForm;
    
    @Action
    void saveProduct() {
        // productForm.price is already a properly parsed BigDecimal
        productService.save(productForm);
    }
}

// Template
&lt;form xis:action="saveProduct"&gt;
    &lt;input type="text" name="product.price" value="${product.price}"/&gt;
    &lt;!-- User types "1.234,56 €", gets parsed to BigDecimal(1234.56) --&gt;
    &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/form&gt;</code></pre>
    </xis:raw>

    <h5>Using Formatters in Templates</h5>
    <p>Formatters also apply when displaying values in templates:</p>
    <xis:raw>
        <pre><code>@Widget
class ProductListWidget {
    
    @ModelData("products")
    List&lt;Product&gt; getProducts() {
        return productService.findAll();
    }
}

public class Product {
    @UseFormatter(MoneyFormatter.class)
    private BigDecimal price;
    
    // When accessed in template, automatically formatted
}

// Template
&lt;div xis:foreach="product:${products}"&gt;
    &lt;span&gt;${product.name}&lt;/span&gt;
    &lt;span&gt;${product.price}&lt;/span&gt; &lt;!-- Shows: "1.234,56 €" --&gt;
&lt;/div&gt;</code></pre>
    </xis:raw>

    <h5>Formatter on Action Parameters</h5>
    <p>Apply formatters to action parameters for type-safe conversions:</p>
    <xis:raw>
        <pre><code>@Action
void updateDiscount(
    @ActionParameter("rate") 
    @UseFormatter(PercentageFormatter.class) 
    BigDecimal discountRate
) {
    productService.applyDiscount(discountRate);
}</code></pre>
        <p><strong>Template:</strong></p>
        <pre><code>&lt;button xis:action="updateDiscount"&gt;
    &lt;xis:parameter name="rate" value="15,5 %"/&gt;
    Apply 15.5% Discount
&lt;/button&gt;</code></pre>
    </xis:raw>

    <h5>Handling Formatting Errors</h5>
    <p>Formatters should throw <code>FormattingException</code> for invalid input:</p>
    <xis:raw>
        <pre><code>import one.xis.formatter.FormattingException;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.Locale;

@Override
public LocalDate parse(String value, Locale locale, ZoneId zoneId) {
    try {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd.MM.yyyy");
        return LocalDate.parse(value, formatter);
    } catch (DateTimeParseException e) {
        throw new FormattingException(
            "Invalid date format. Expected: dd.MM.yyyy", e
        );
    }
}</code></pre>
        <p>Formatting errors appear as validation errors in the template.</p>
    </xis:raw>

    <h5>Formatter Registration</h5>
    <p>Register global formatters for specific types:</p>
    <xis:raw>
        <pre><code>@Configuration
public class FormatterConfig {
    
    @Bean
    public FormatterRegistry formatterRegistry() {
        FormatterRegistry registry = new FormatterRegistry();
        registry.registerFormatter(LocalDate.class, new GermanDateFormatter());
        registry.registerFormatter(Price.class, new PriceFormatter());
        return registry;
    }
}</code></pre>
        <p>With global registration, you don't need <code>@UseFormatter</code> on every field of that type.</p>
    </xis:raw>

    <h5>Note on Date/Time Inputs</h5>
    <p>For date and time values, prefer HTML5 input types with built-in pickers:</p>
    <xis:raw>
        <pre><code>&lt;!-- Use native date picker instead of custom formatting --&gt;
&lt;input type="date" name="event.date" value="${event.date}"/&gt;
&lt;input type="time" name="event.time" value="${event.time}"/&gt;
&lt;input type="datetime-local" name="event.timestamp" value="${event.timestamp}"/&gt;</code></pre>
        <p>These work with standard Java temporal types (LocalDate, LocalTime, LocalDateTime) without custom formatters.</p>
    </xis:raw>

    <h5>Best Practices</h5>
    <xis:raw>
        <ul>
            <li><strong>Thread Safety:</strong> Formatters must be stateless and thread-safe (reused across requests)</li>
            <li><strong>Null Handling:</strong> Handle null values gracefully - return null or empty string</li>
            <li><strong>Error Messages:</strong> Throw FormattingException with clear messages for invalid input</li>
            <li><strong>Locale Awareness:</strong> Consider user locale for money, percentages, decimal separators</li>
            <li><strong>Immutable Objects:</strong> Parse to immutable types when possible for thread safety</li>
            <li><strong>Validation:</strong> Formatters handle conversion, not validation - use @Validated for business rules</li>
        </ul>
    </xis:raw>

    <h5>Formatter vs Validation</h5>
    <p>Understanding the difference:</p>
    <xis:raw>
        <ul>
            <li><strong>Formatter:</strong> Converts between string and Java type ("1.234,56 €" ↔ BigDecimal)</li>
            <li><strong>Validator:</strong> Checks business rules (price must be positive, within range, etc.)</li>
        </ul>
        <p>Use formatters for representation, validators for business constraints. A value can be formatted correctly 
            but still fail validation (e.g., "-10,00 €" formats to BigDecimal(-10) but fails @Min(0) validation).</p>
    </xis:raw>

    <p><strong>Bidirectional Flow:</strong> Formatters work in both directions - parsing user input in forms 
        (String → Java) and formatting values for display in templates (Java → String). This ensures consistent 
        representation across your application.</p>
</xis:template>
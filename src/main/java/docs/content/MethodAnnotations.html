<xis:template xmlns:xis="http://www.w3.org/1999/XSL/Transform">
    <h3>Method Annotations</h3>
    <p>
        XIS provides a set of annotations for controller methods that define how methods interact with the 
        framework, handle user actions, and manage data. These annotations are the building blocks for creating 
        interactive web applications with clear separation of concerns.
    </p>
    <p>
        <strong>Note:</strong> For class-level annotations like <code>@WelcomePage</code>, <code>@RefreshOnUpdateEvents</code>, 
        and <code>@Roles</code> applied to classes, see the <a href="#" xis:page="ClassAnnotations">Class Annotations</a> section.
    </p>

    <h5>@ModelData</h5>
    <p>
        Provides data to templates. The method's return value becomes available in the template using the method 
        name as the key, or an explicitly specified key via the annotation parameter.
    </p>
    <pre><code>@ModelData
List&lt;User&gt; users() $&#8203;{
    return userService.findAll();
}

@ModelData("currentUser")
User getLoggedInUser() $&#8203;{
    return securityContext.getCurrentUser();
}</code></pre>
    <p>In templates, access the data using the key:</p>
    <pre><code>&lt;h1&gt;Welcome $&#8203;{currentUser.name}&lt;/h1&gt;
&lt;ul xis:foreach="user:$&#8203;{users}"&gt;
    &lt;li&gt;$&#8203;{user.name} ($&#8203;{user.email})&lt;/li&gt;
&lt;/ul&gt;</code></pre>

    <h5>@Action</h5>
    <p>
        Handles user interactions such as button clicks, link navigation, or form submissions. Actions can return 
        different types to control navigation: <code>PageResponse</code>, <code>WidgetResponse</code>, 
        <code>Class&lt;?&gt;</code> for navigation, or <code>void</code> to stay on the current page.
    </p>
    <pre><code>@Action("delete")
void deleteUser(String userId) $&#8203;{
    userService.delete(userId);
    // Returns void - stays on current page
}

@Action("viewDetails")
Class&lt;?&gt; viewUserDetails(String userId) $&#8203;{
    return UserDetailsPage.class; // Navigate to different page
}

@Action("updateWidget")
WidgetResponse refreshContent() $&#8203;{
    return new WidgetResponse(UpdatedContentWidget.class);
}</code></pre>

    <h5>@FormData</h5>
    <p>
        Binds form input data to method parameters with automatic type conversion and validation support. 
        Can be used both as a method annotation and as a parameter annotation.
    </p>
    <pre><code>@Action("save")
void saveUser(@FormData("user") User user) $&#8203;{
    userService.save(user);
}</code></pre>
    <p>Used with form binding in templates:</p>
    <pre><code>&lt;form xis:binding="user"&gt;
    &lt;input xis:binding="name" type="text" name="name"/&gt;
    &lt;input xis:binding="email" type="email" name="email"/&gt;
    &lt;button xis:action="save" type="submit"&gt;Save&lt;/button&gt;
&lt;/form&gt;</code></pre>

    <h5>@RequestScope (â†’ @RequestContextVar)</h5>
    <p>
        Injects request-scoped data that is available throughout the current request lifecycle. XIS automatically 
        makes return values of <code>@ModelData</code> methods available in the request scope, allowing other 
        methods to access this data without recomputing it.
    </p>
    <pre><code>@ModelData("user")
User loadUser() $&#8203;{
    return userService.getCurrentUser(); // Computed once
}

@ModelData("permissions")
List&lt;Permission&gt; loadPermissions(@RequestScope("user") User user) $&#8203;{
    // User data injected from request scope
    return permissionService.getPermissionsForUser(user.getId());
}

@Action("updateProfile")
void updateProfile(@FormData("profile") UserProfile profile,
                  @RequestScope("user") User currentUser) $&#8203;{
    if (currentUser.getId().equals(profile.getUserId())) $&#8203;{
        userService.updateProfile(profile);
    }
}</code></pre>

    <h5>@LocalStorage</h5>
    <p>
        Accesses the browser's localStorage for persistent client-side data storage. Data survives page reloads, 
        browser restarts, and persists until explicitly cleared. Perfect for user preferences and long-term settings.
    </p>
    <p>
        <strong>Behavior:</strong>
    </p>
    <ul>
        <li><strong>On methods:</strong> The return value is <strong>always written</strong> to localStorage</li>
        <li><strong>As parameter:</strong> The value is <strong>read from</strong> localStorage</li>
        <li><strong>Updates:</strong> Changes do not automatically trigger updates in other components. Use 
            <code>@Action(updateEventKeys = {...})</code> to notify other widgets via <code>@RefreshOnUpdateEvents</code></li>
    </ul>
    <pre><code>// Method: Writes return value to localStorage
@LocalStorage("userTheme")
String getUserTheme() $&#8203;{
    return "dark"; // This value is written to localStorage
}

// Parameter: Reads current value from localStorage
@Action("logTheme")
void logTheme(@LocalStorage("userTheme") String currentTheme) $&#8203;{
    System.out.println("Current theme: " + currentTheme);
}

// Action: Updates localStorage and notifies other widgets
@Action(value = "changeTheme", updateEventKeys = $&#8203;{"theme-changed"})
@LocalStorage("userTheme") // Return value is saved to localStorage
String changeTheme(@ActionParameter("newTheme") String newTheme) $&#8203;{
    return newTheme; // Saved to localStorage, emits "theme-changed" event
}</code></pre>
    <p>In templates, access with the <code>localStorage.</code> prefix:</p>
    <pre><code>&lt;body class="theme-$&#8203;{localStorage.userTheme}"&gt;
    &lt;button xis:action="changeTheme"&gt;
        &lt;xis:parameter name="newTheme" value="light"/&gt;
        Switch to Light
    &lt;/button&gt;
    <h5>@SessionStorage</h5>
    <p>
        Manages client-side state using the browser's sessionStorage. Data persists across page navigations within 
        the same browser tab/session but is cleared when the tab is closed. Ideal for tab-specific UI state like 
        selected tabs or temporary form data.
    </p>
    <p>
        <strong>Behavior:</strong>
    </p>
    <ul>
        <li><strong>On methods:</strong> The return value is <strong>always written</strong> to sessionStorage</li>
        <li><strong>As parameter:</strong> The value is <strong>read from</strong> sessionStorage</li>
        <li><strong>Updates:</strong> Changes do not automatically trigger updates in other components. Use 
            <code>@Action(updateEventKeys = {...})</code> to notify other widgets via <code>@RefreshOnUpdateEvents</code></li>
    </ul>
    <pre><code>// Method: Writes return value to sessionStorage
@SessionStorage("selectedTab")
String getSelectedTab() $&#8203;{
    return "dashboard"; // This value is written to sessionStorage
}

// Parameter: Reads current value from sessionStorage
@ModelData
String getTabInfo(@SessionStorage("selectedTab") String tab) $&#8203;{
    return "Currently viewing: " + tab;
}

// Action: Updates sessionStorage and notifies other widgets
@Action(value = "selectTab", updateEventKeys = $&#8203;{"tab-changed"})
@SessionStorage("selectedTab") // Return value is saved to sessionStorage
String selectTab(@ActionParameter("tab") String tab) $&#8203;{
    return tab; // Saved to sessionStorage, emits "tab-changed" event
}</code></pre>
    <p>In templates, access with the <code>sessionStorage.</code> prefix:</p>
    <pre><code>&lt;nav&gt;
    &lt;button class="$&#8203;{sessionStorage.selectedTab == 'dashboard' ? 'active' : ''}"
            xis:action="selectTab"&gt;
        &lt;xis:parameter name="tab" value="dashboard"/&gt;
        Dashboard
    &lt;/button&gt;
&lt;/nav&gt;</code></pre>
    <p>Other widgets can reload when tab selection changes:</p>
    <pre><code>@Widget
@RefreshOnUpdateEvents("tab-changed")
class TabContentWidget $&#8203;{
    // This widget will reload when "tab-changed" event is emitted
}</code></pre>ard
    &lt;/button&gt;
&lt;/nav&gt;</code></pre>
    <p>Other widgets can reload when tab selection changes:</p>
    <pre><code>@Widget
@RefreshOnUpdateEvents("tab-changed")
class TabContentWidget $&#8203;{
    // This widget will reload when "tab-changed" event is emitted
}</code></pre>

    <h5>@Roles</h5>
    <p>
        Provides role-based access control for methods and classes. Works with security frameworks to enforce 
        authorization. Can be applied at class level (affects all methods) or method level (specific actions).
    </p>
    <pre><code>@Page("/admin-panel.html")
@Roles($&#8203;{"ADMIN", "MODERATOR"}) // Class-level
class AdminPanelPage $&#8203;{
    
    @ModelData
    List&lt;User&gt; getAllUsers() $&#8203;{
        return userService.findAll(); // Inherits class roles
    }
    
    @Action("deleteUser")
    @Roles("ADMIN") // Only ADMIN can delete
    void deleteUser(String userId) $&#8203;{
        userService.delete(userId);
    }
    
    @Action("banUser")
    @Roles($&#8203;{"ADMIN", "MODERATOR"}) // Multiple roles
    void banUser(String userId) $&#8203;{
        userService.ban(userId);
    }
}</code></pre>

</xis:template>    }</xis:raw></code></pre>
    <p>XIS automatically makes the return values of @ModelData methods available in the request scope using the same key. You can then inject this data into other methods using @RequestScope. This creates a clean data flow where expensive operations (like database queries) only happen once per request, and the results are shared across all methods that need them.</p>

    <h6>@Roles</h6>
    <p>Provides role-based access control for methods and classes. Used in conjunction with security frameworks to enforce authorization.</p>
    <pre><code class="language-java"><xis:raw><xis:raw>@Page("/admin-panel.html")
@Roles(&#123;"ADMIN", "MODERATOR"}) // Class-level: entire page requires these roles
class AdminPanelPage &#123;
    
    @ModelData
    List&lt;User&gt; getAllUsers() &#123;
        return userService.findAll(); // Inherits class-level roles
    }
    
    @Action("deleteUser")
    @Roles("ADMIN") // Method-level: only ADMIN can delete users
    void deleteUser(String userId) &#123;
        userService.delete(userId);
    }
    
    @Action("banUser") 
    @Roles(&#123;"ADMIN", "MODERATOR"}) // Multiple roles allowed
    void banUser(String userId) &#123;
        userService.ban(userId);
    }
}</xis:raw></code></pre>

    <h6>@Refresh</h6>
    <p>Triggers a refresh of specified controllers after method execution. Useful for updating related components when data changes.</p>
    <pre><code class="language-java"><xis:raw>@Widget
class UserListWidget &#123;
    @ModelData
    List&lt;User&gt; getUsers() &#123;
        return userService.findAll();
    }
}

@Widget  
class UserFormWidget &#123;
    @Action("saveUser")
    @Refresh(controllerCLass = UserListWidget.class) // Refresh user list after save
    void saveUser(@FormData("user") User user) &#123;
        userService.save(user);
    }
    
    @Action("deleteUser")
    @Refresh(controllerName = "userListWidget") // Alternative: refresh by name
    void deleteUser(String userId) &#123;
        userService.delete(userId);
    }
}</xis:raw></code></pre>

    <h6>@LocalDatabase</h6>
    <p>Accesses the browser's IndexedDB for client-side structured data storage. Perfect for offline functionality and large datasets that exceed localStorage limits.</p>
    <pre><code class="language-java"><xis:raw>@Widget
class OfflineDataWidget &#123;
    @LocalDatabase("userData")
    String getUserData() &#123;
        return "&#123;}"; // Default JSON value
    }
    
    @Action("saveOfflineData")
    void saveData(@FormData("data") UserData data,
                  @LocalDatabase("userData") String existingData) &#123;
        // Existing data is automatically loaded from IndexedDB
        // New data will be automatically saved
        logger.info("Previous data: " + existingData);
    }
}</xis:raw></code></pre>
    <p>In templates, localDatabase values are accessed with the <code>localDatabase.</xis:raw></code> prefix:</p>
    <pre><code class="language-html"><xis:raw>&lt;div xis:if="&#036;&#123;localDatabase.userData != '&#123;}'}"&gt;
    &lt;h3&gt;Offline Data Available&lt;/h3&gt;
    &lt;p&gt;Data: &#036;&#123;localDatabase.userData}&lt;/p&gt;
&lt;/div&gt;
&lt;div xis:if="&#036;&#123;localDatabase.userData == '&#123;}'}"&gt;
    &lt;p&gt;No offline data found&lt;/p&gt;
&lt;/div&gt;</xis:raw></code></pre>

</xis:template>m form data to reactive state management.</p>

    <h6>@ModelData</h6>
    <p>Provides data to templates. The key defaults to the method name or can be specified explicitly.</p>
    <pre><code class="language-java"><xis:raw>@ModelData
List&lt;User&gt; users() &#123;
    return userService.findAll();
}

@ModelData("currentUser")
User getLoggedInUser() &#123;
    return securityContext.getCurrentUser();
}</xis:raw></code></pre>
    <p>In templates, access the data using the key:</p>
    <pre><code class="language-html"><xis:raw>&lt;!DOCTYPE html&gt;
&lt;html xmlns:xis="https://xis.one/xsd"&gt;
&lt;body&gt;
    &lt;h1&gt;Welcome &#036;&#123;currentUser.name}&lt;/h1&gt;
    &lt;ul&gt;
        &lt;div xis:foreach="user:&#036;&#123;users}"&gt;
            &lt;li&gt;&#036;&#123;user.name} (&#036;&#123;user.email})&lt;/li&gt;
        &lt;/div&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</xis:raw></code></pre>

    <h6>@FormData</h6>
    <p>Binds form input data to method parameters with automatic validation support.</p>
    <pre><code class="language-java"><xis:raw>@Action("save")
void saveUser(@FormData("user") User user) &#123;
    userService.save(user);
}</xis:raw></code></pre>
    <p>Used with form binding in templates:</p>
    <pre><code class="language-html"><xis:raw>&lt;form xis:binding="user"&gt;
    &lt;input xis:binding="name" type="text" name="name"&gt;
    &lt;input xis:binding="email" type="email" name="email"&gt;
    &lt;button xis:action="save" type="submit"&gt;Save User&lt;/button&gt;
&lt;/form&gt;</xis:raw></code></pre>

    <h6>@Action</h6>
    <p>Handles user interactions like button clicks or form submissions.</p>
    <pre><code class="language-java"><xis:raw>@Action("delete")
void deleteUser(String userId) &#123;
    userService.delete(userId);
}</xis:raw></code></pre>

    <h6>@GlobalVariable</h6>
    <p>Provides reactive global variables that are shared across all components during request processing. These
        variables are automatically updated in all templates when they change - perfect for sharing data between widgets
        on the same page.</p>
    <pre><code class="language-java"><xis:raw>// UserHeaderWidget.java
@Widget
class UserHeaderWidget &#123;
    @GlobalVariable("currentUserName")
    String getCurrentUserName() &#123;
        return securityContext.getCurrentUser().getName();
    }
}

// UserProfileWidget.java
@Widget
class UserProfileWidget &#123;
    @Action("updateProfile")
    void updateProfile(@FormData("profile") UserProfile profile) &#123;
        userService.update(profile);
        // Global variable will automatically update in UserHeaderWidget
    }
}</xis:raw></code></pre>
    <p>In templates, global variables are accessed with the <code>global.</xis:raw></code> prefix and update reactively across all
        components:</p>
    <pre><code class="language-html"><xis:raw>&lt;!-- UserHeaderWidget.html --&gt;
&lt;header&gt;
    &lt;div&gt;Welcome &#036;&#123;global.currentUserName}!&lt;/div&gt;
    &lt;span xis:if="&#036;&#123;global.currentUserName != null}"&gt;
        Status: Logged in
    &lt;/span&gt;
&lt;/header&gt;

&lt;!-- UserProfileWidget.html --&gt;
&lt;div class="profile"&gt;
    &lt;h2&gt;Profile for &#036;&#123;global.currentUserName}&lt;/h2&gt;
    &lt;form xis:binding="profile"&gt;
        &lt;input xis:binding="displayName" value="&#036;&#123;global.currentUserName}"&gt;
        &lt;button xis:action="updateProfile"&gt;Update&lt;/button&gt;
    &lt;/form&gt;
&lt;/div&gt;</xis:raw></code></pre>

    <h6>@ClientStorage</h6>
    <p>Manages server-side state per client/session. Unlike LocalStorage and SessionStorage which store data in the browser, 
        ClientStorage keeps data on the server, making it suitable for sensitive data, larger datasets, or data that should 
        not be accessible via browser DevTools. Data persists for the duration of the client session.</p>
    <p>
        <strong>Behavior:</strong>
    </p>
    <ul>
        <li><strong>On methods:</strong> The return value is <strong>always written</strong> to server-side client storage</li>
        <li><strong>As parameter:</strong> The value is <strong>read from</strong> server-side client storage</li>
        <li><strong>Updates:</strong> Changes do not automatically trigger updates in other components. Use 
            <code>@Action(updateEventKeys = {...})</code> to notify other widgets via <code>@RefreshOnUpdateEvents</code></li>
    </ul>
    <pre><code class="language-java"><xis:raw>// Method: Writes return value to server-side client storage
@ClientStorage("selectedTab")
String getSelectedTab() &#123;
    return "dashboard"; // This value is written to client storage on server
}

// Parameter: Reads current value from server-side client storage
@ModelData
String getActiveContent(@ClientStorage("selectedTab") String tab) &#123;
    return contentService.getContentForTab(tab);
}

// Action: Updates client storage and notifies other widgets
@Action(value = "selectTab", updateEventKeys = &#123;"tab-changed"})
@ClientStorage("selectedTab") // Return value is saved to client storage
String selectTab(@ActionParameter("tab") String tab) &#123;
    return tab; // Saved to client storage, emits "tab-changed" event
}</xis:raw></code></pre>
    <p>In templates, access with the <code>clientStorage.</code> prefix:</p>
    <pre><code class="language-html"><xis:raw>&lt;nav&gt;
    &lt;button class="&#036;&#123;clientStorage.selectedTab == 'dashboard' ? 'active' : ''}"
            xis:action="selectTab"&gt;
        &lt;xis:parameter name="tab" value="dashboard"/&gt;
        Dashboard
    &lt;/button&gt;
    &lt;button class="&#036;&#123;clientStorage.selectedTab == 'profile' ? 'active' : ''}"
            xis:action="selectTab"&gt;
        &lt;xis:parameter name="tab" value="profile"/&gt;
        Profile
    &lt;/button&gt;
&lt;/nav&gt;</xis:raw></code></pre>
    <p>Other widgets can reload when client storage changes:</p>
    <pre><code class="language-java"><xis:raw>@Widget
@RefreshOnUpdateEvents("tab-changed")
class TabContentWidget &#123;
    // This widget will reload when "tab-changed" event is emitted
}</xis:raw></code></pre>

    <h6>@LocalStorage</h6>
    <p>Accesses the browser's localStorage for persistent client-side data storage. Data survives page reloads, browser
        restarts, and even computer restarts - until explicitly cleared by the user or application. Perfect for user
        preferences, settings, and long-term state.</p>
    <pre><code class="language-java"><xis:raw>// ThemeWidget.java
@Widget
class ThemeWidget &#123;
    @LocalStorage("userTheme")
    String getUserTheme() &#123;
        return "dark"; // Default value
    }

    @Action("changeTheme")
    void changeTheme(@ActionParameter("theme") String theme) &#123;
        // Will automatically save to localStorage
    }
}

// LayoutWidget.java
@Widget
class LayoutWidget &#123;
    // Can access same localStorage from different widget
    String getLayoutClass(@LocalStorage("userTheme") String theme) &#123;
        return "layout-" + theme;
    }
}</xis:raw></code></pre>
    <p>In templates, localStorage values are accessed with the <code>localStorage.</xis:raw></code> prefix and update reactively
        across all components:</p>
    <pre><code class="language-html"><xis:raw>&lt;!DOCTYPE html&gt;
&lt;html xmlns:xis="https://xis.one/xsd"&gt;
&lt;body class="theme-&#036;&#123;localStorage.userTheme}"&gt;
    &lt;!-- ThemeWidget.html --&gt;
    &lt;div class="theme-selector"&gt;
        &lt;h3&gt;Choose Theme&lt;/h3&gt;
        &lt;button class="&#036;&#123;localStorage.userTheme == 'light' ? 'selected' : ''}"
                xis:action="changeTheme"&gt;
            &lt;xis:parameter name="theme" value="light"/&gt;
            Light Theme
        &lt;/button&gt;
        &lt;button class="&#036;&#123;localStorage.userTheme == 'dark' ? 'selected' : ''}"
                xis:action="changeTheme"&gt;
            &lt;xis:parameter name="theme" value="dark"/&gt;
            Dark Theme
        &lt;/button&gt;
        &lt;p&gt;Current theme: &#036;&#123;localStorage.userTheme}&lt;/p&gt;
    &lt;/div&gt;

    &lt;!-- LayoutWidget.html --&gt;
    &lt;main class="layout-&#036;&#123;localStorage.userTheme}"&gt;
        &lt;div xis:if="&#036;&#123;localStorage.userTheme == 'dark'}"&gt;
            &lt;style&gt;.content &#123; background: #333; color: white; }&lt;/style&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;This content adapts to the stored theme: &#036;&#123;localStorage.userTheme}&lt;/p&gt;
        &lt;/div&gt;
    &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;</xis:raw></code></pre>

    <h6>@RequestScope</h6>
    <p>Injects request-scoped data that is available throughout the current request lifecycle. This is particularly
        useful when you need to pass data between different methods during the same request processing. The output of
        one method becomes available as input to subsequent methods within the same request cycle.</p>
    <pre><code class="language-java"><xis:raw>@Page("/user-details.html")
class UserDetailsPage &#123;

    @ModelData("user")
    User loadUser() &#123;
        User user = userService.getCurrentUser();
        // This method sets requestScope data automatically
        return user;
    }

    @ModelData("permissions")
    List&lt;Permission&gt; loadPermissions(@RequestScope("user") User user) &#123;
        // The user from the previous method is automatically injected here
        return permissionService.getPermissionsForUser(user.getId());
    }

    @ModelData("auditLog")
    List&lt;AuditEntry&gt; loadAuditLog(@RequestScope("user") User user) &#123;
        // Same user data is available here too
        return auditService.getLogForUser(user.getId());
    }

    @Action("updateProfile")
    void updateProfile(@FormData("profile") UserProfile profile,
                      @RequestScope("user") User currentUser) &#123;
        // Access the same user data in action methods
        if (currentUser.getId().equals(profile.getUserId())) &#123;
            userService.updateProfile(profile);
        }
    }
}</xis:raw></code></pre>
    <p>XIS automatically makes the return values of @ModelData methods available in the request scope using the same
        key. You can then inject this data into other methods using @RequestScope. This creates a clean data flow where
        expensive operations (like database queries) only happen once per request, and the results are shared across all
        methods that need them.</p>

</xis:template>
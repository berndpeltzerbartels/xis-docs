<xis:template xmlns:xis="http://www.w3.org/1999/XSL/Transform">
    <h3>${chapterHeadline}</h3>
    <p>
        XIS provides several annotations that are applied at the class level to configure controllers, define 
        application structure, and control component behavior. These annotations work on any class, not just 
        controllers, and provide framework-wide functionality.
    </p>

    <h5>@Page and @Widget</h5>
    <p>
        The fundamental annotations that define your application structure. <code>@Page</code> marks a controller 
        as a page with a specific URL path, while <code>@Widget</code> marks a controller as a reusable component.
    </p>
    <p>
        These annotations are covered in detail in the <a href="#" xis:page="PagesAndWidgets">Pages and Widgets</a> 
        section. Quick reference:
    </p>
    <pre><code>@Page("/users/list.html")
class UserListPage $&#8203;{ /* ... */ }

@Widget // ID defaults to "ProductCard"
class ProductCard $&#8203;{ /* ... */ }

@Widget("customId")
class CustomWidget $&#8203;{ /* ... */ }</code></pre>

    <h5>@WelcomePage</h5>
    <p>
        Designates a page as the default welcome page (landing page) of your application. Exactly one page in 
        your application must be annotated with <code>@WelcomePage</code>. This page is displayed when users 
        access the root URL (<code>/</code>) or when no other URL mapping matches.
    </p>
    <p>
        <strong>Important:</strong> The framework will throw an <code>IllegalStateException</code> if zero or 
        multiple pages are annotated with <code>@WelcomePage</code>. There must be exactly one.
    </p>
    <pre><code>@WelcomePage
@Page("/index.html")
class HomePage $&#8203;{
    @ModelData
    String getWelcomeMessage() $&#8203;{
        return "Welcome to XIS Framework!";
    }
}</code></pre>
    <p>
        <strong>Use Cases:</strong>
    </p>
    <ul>
        <li>Landing page / home page of your application</li>
        <li>Dashboard that users see after login</li>
        <li>Default page when accessing the application root URL</li>
    </ul>
    
    <h6>Special Case: Pages with Path Variables</h6>
    <p>
        In the rare scenario where your welcome page URL contains path variables (e.g., <code>@Page("/category/$&#8203;{name}.html")</code>), 
        you cannot use the default <code>@WelcomePage</code> annotation alone. The framework needs to know which 
        concrete values to use for those path variables when a user accesses <code>/</code>.
    </p>
    <p>
        <strong>Example scenario:</strong> You want to display a category page at <code>/</code>, but your page 
        is defined with a path variable to also handle URLs like <code>/category/electronics.html</code> and 
        <code>/category/books.html</code>.
    </p>
    <p>
        For this special case, use the <code>value</code> parameter of <code>@WelcomePage</code> to specify 
        a concrete URL that matches your page pattern:
    </p>
    <pre><code>@WelcomePage("/category/electronics.html")  // Concrete URL with actual values
@Page("/category/$&#8203;{name}.html")              // Pattern with path variable
class CategoryPage $&#8203;{
    @ModelData
    String getCategoryName(@PathVariable("name") String name) $&#8203;{
        return name; // Will be "electronics" when accessing /
    }
}</code></pre>
    <p>
        <strong>Validation:</strong> The framework validates at startup:
    </p>
    <ul>
        <li>If the page has path variables, the concrete URL in <code>@WelcomePage(value)</code> must match the pattern in <code>@Page</code></li>
        <li>If the page has <strong>no</strong> path variables, you must <strong>not</strong> provide a <code>value</code> in <code>@WelcomePage</code></li>
        <li>In both cases, an <code>IllegalStateException</code> is thrown if the validation fails</li>
    </ul>
    <p>
        This strict validation prevents configuration errors at deployment time and ensures the framework can 
        correctly handle all URL mappings.
    </p>
    <p>
        <strong>Important notes:</strong>
    </p>
    <ul>
        <li>The <code>value</code> parameter is <strong>only needed</strong> when your page URL contains path variables</li>
        <li>For regular pages without path variables, use <code>@WelcomePage</code> without the <code>value</code> parameter</li>
        <li>The concrete URL must be a valid instance of your page's URL pattern</li>
        <li>Users can still access other paths like <code>/category/books.html</code> directly - the welcome page 
            value only affects what happens when accessing <code>/</code></li>
    </ul>

    <h5>@RefreshOnUpdateEvents</h5>
    <p>
        Registers a widget to automatically reload when specific update events are emitted by actions. This 
        annotation enables a clean publish-subscribe pattern for communication between widgets without tight 
        coupling.
    </p>
    <p>
        <strong>How it works:</strong> When an action method includes <code>@Action(updateEventKeys = $&#8203;{...})</code>, 
        XIS automatically reloads all widgets that are listening to those event keys via 
        <code>@RefreshOnUpdateEvents</code>.
    </p>
    <pre><code>// Widget that listens for events
@Widget
@RefreshOnUpdateEvents("user-data-changed")
class UserListWidget $&#8203;{
    @ModelData
    List&lt;User&gt; getUsers() $&#8203;{
        return userService.findAll();
    }
}

// Widget that emits events
@Widget
class UserFormWidget $&#8203;{
    @Action(value = "saveUser", updateEventKeys = $&#8203;{"user-data-changed"})
    void saveUser(@FormData("user") User user) $&#8203;{
        userService.save(user);
        // UserListWidget will automatically reload
    }
}

// Multiple events supported
@Widget
@RefreshOnUpdateEvents($&#8203;{"user-data-changed", "settings-updated", "theme-changed"})
class DashboardWidget $&#8203;{
    // Reloads when any of these events is emitted
}</code></pre>
    <p>
        <strong>Benefits:</strong>
    </p>
    <ul>
        <li>Decouples widgets - emitter doesn't need to know about listeners</li>
        <li>Multiple widgets can react to the same event</li>
        <li>One widget can listen to multiple events</li>
        <li>Clean separation of concerns and maintainable code</li>
    </ul>
    <p>
        See also: <a href="#" xis:page="MethodAnnotations">@Action annotation</a> for details on emitting 
        update events.
    </p>

    <h5>@Roles</h5>
    <p>
        When applied at the class level, <code>@Roles</code> enforces role-based access control for all methods 
        in the controller. Users must have one of the specified roles to access any method in the class, unless 
        overridden by method-level <code>@Roles</code> annotations.
    </p>
    <p>
        <strong>Note:</strong> Requires the <code>xis-authentication</code> dependency. See the 
        <a href="#" xis:page="Security">Security</a> section for authentication setup.
    </p>
    <pre><code>// All methods require ADMIN role
@Page("/admin/dashboard.html")
@Roles("ADMIN")
class AdminDashboard $&#8203;{
    
    @ModelData
    List&lt;User&gt; getAllUsers() $&#8203;{
        return userService.findAll(); // Requires ADMIN role
    }
    
    @Action("deleteUser")
    void deleteUser(String userId) $&#8203;{
        userService.delete(userId); // Requires ADMIN role
    }
}

// Multiple roles allowed at class level
@Widget
@Roles($&#8203;{"ADMIN", "MODERATOR"})
class ModerationWidget $&#8203;{
    // All methods accessible by ADMIN or MODERATOR
    
    @Action("approvePost")
    void approvePost(String postId) $&#8203;{
        postService.approve(postId);
    }
    
    @Action("deletePost")
    @Roles("ADMIN") // Method-level: further restricts to ADMIN only
    void deletePost(String postId) $&#8203;{
        postService.delete(postId);
    }
}</code></pre>
    <p>
        <strong>Inheritance:</strong> Method-level <code>@Roles</code> annotations do not inherit from the class 
        level. If a method has its own <code>@Roles</code>, it completely overrides the class-level roles for 
        that specific method.
    </p>
    <p>
        See also: <a href="#" xis:page="MethodAnnotations">@Roles on methods</a> for method-level access control.
    </p>

</xis:template>

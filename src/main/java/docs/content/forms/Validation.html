<xis:template xmlns:xis="http://www.w3.org/1999/XSL/Transform">
    <h3>${chapterHeadline}</h3>
    <p>XIS provides its own validation framework with built-in annotations for declarative form validation.</p>

    <h5>Basic Validation</h5>
    <p>Add XIS validation annotations to your form object fields:</p>
    <xis:raw>
        <pre><code>import one.xis.annotation.Mandatory;
import one.xis.annotation.MinLength;
import one.xis.annotation.Email;

public class UserForm {
    
    @Mandatory  // Validates not null AND not empty/blank
    @MinLength(2)  // TODO: Will move to different module
    private String firstName;
    
    @Mandatory
    @Email
    private String email;
    
    @Mandatory
    private Integer age;  // Use Integer, not int, to allow null checking
    
    // Getters and setters
}</code></pre>
        <p><strong>Note:</strong> <code>@Mandatory</code> combines null and empty checks in a single annotation. 
            Validation messages are looked up from message properties files using keys.</p>
    </xis:raw>

    <h5>Enabling Validation</h5>
    <p>Use <code>@Validate</code> annotation on the form data field to enable automatic validation:</p>
    <xis:raw>
        <pre><code>@Widget
class UserFormWidget {
    
    @FormData("user")
    @Validate
    UserForm userForm;
    
    @Action
    void saveUser() {
        // This only executes if validation passes
        userService.save(userForm);
    }
}</code></pre>
        <p>If validation fails, the action method is <strong>not executed</strong> and validation errors are 
            automatically available in the template.</p>
    </xis:raw>

    <h5>Displaying Validation Errors</h5>
    <p>XIS makes validation errors available via the <code>errors</code> variable:</p>
    <xis:raw>
        <pre><code>&lt;form xis:action="saveUser"&gt;
    &lt;div&gt;
        &lt;label&gt;First Name&lt;/label&gt;
        &lt;input type="text" name="user.firstName" value="${user.firstName}"/&gt;
        &lt;span class="error" xis:if="${errors['user.firstName']}"&gt;
            ${errors['user.firstName']}
        &lt;/span&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
        &lt;label&gt;Email&lt;/label&gt;
        &lt;input type="email" name="user.email" value="${user.email}"/&gt;
        &lt;span class="error" xis:if="${errors['user.email']}"&gt;
            ${errors['user.email']}
        &lt;/span&gt;
    &lt;/div&gt;
    
    &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/form&gt;</code></pre>
    </xis:raw>

    <h5>Common Validation Annotations</h5>
    <xis:raw>
        <table border="1" style="border-collapse:collapse;">
            <tr>
                <th>Annotation</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
            <tr>
                <td><code>@Mandatory</code></td>
                <td>Value must not be null, empty, or whitespace</td>
                <td><code>@Mandatory private String name;</code></td>
            </tr>
            <tr>
                <td><code>@Email</code></td>
                <td>String must be valid email format</td>
                <td><code>@Email private String email;</code></td>
            </tr>
            <tr>
                <td><code>@MinLength</code></td>
                <td>String minimum length (TODO: will move to different module)</td>
                <td><code>@MinLength(8) private String password;</code></td>
            </tr>
            <tr>
                <td><code>@Iban</code></td>
                <td>Valid IBAN format (custom example)</td>
                <td><code>@Iban private String accountNumber;</code></td>
            </tr>
        </table>
    </xis:raw>

    <h5>@LabelKey - Context-Specific Error Messages</h5>
    <p>The <code>@LabelKey</code> annotation allows you to provide context-specific field labels in validation error messages. 
        This is particularly useful when the same validation annotation is used in different contexts requiring different labels.</p>
    
    <p><strong>Why @LabelKey?</strong> Imagine validating monetary amounts: the same <code>@Money</code> validation logic 
        applies to both "purchase price" (Einkaufspreis) and "sales tax" (Umsatzsteuer), but the error messages should 
        use the appropriate field-specific label.</p>

    <h6>Basic @LabelKey Usage</h6>
    <xis:raw>
        <pre><code>import one.xis.annotation.LabelKey;
import one.xis.annotation.Email;

public class CustomerForm {
    
    @Mandatory
    @Email
    private String email;  // Uses default label "email"
    
    @Mandatory
    @Email
    @LabelKey("email2")  // Uses custom label "email2"
    private String secondEmail;
}</code></pre>
    </xis:raw>

    <h6>Properties File Setup</h6>
    <p>Define labels in your properties files using the keys specified in <code>@LabelKey</code>:</p>
    <xis:raw>
        <pre><code># messages_de.properties
# Field labels
email=E-Mail-Adresse
email2=Zweite E-Mail-Adresse

# Validation message template with ${label} placeholder
validation.email.invalid=Die angegebene ${label} ist keine gültige E-Mail</code></pre>
    </xis:raw>

    <h6>Result</h6>
    <p>The validation framework replaces <code>${label}</code> with the appropriate label:</p>
    <ul>
        <li><code>email</code> field error: "Die angegebene E-Mail-Adresse ist keine gültige E-Mail"</li>
        <li><code>secondEmail</code> field error: "Die angegebene Zweite E-Mail-Adresse ist keine gültige E-Mail"</li>
    </ul>

    <h6>Money Validation Example</h6>
    <p>A more practical example with custom <code>@Money</code> validation:</p>
    <xis:raw>
        <pre><code>public class ProductForm {
    
    @Mandatory
    @Money(maxValue = 1000000)
    @LabelKey("purchasePrice")
    private String purchasePrice;
    
    @Mandatory
    @Money(maxValue = 100000)
    @LabelKey("salesTax")
    private String salesTax;
}</code></pre>
        <pre><code># messages_de.properties
purchasePrice=Einkaufspreis
salesTax=Umsatzsteuer
validation.money.invalid=Der angegebene ${label} ist ungültig
validation.money.exceeds=Der angegebene ${label} überschreitet den Maximalwert von ${max}</code></pre>
    </xis:raw>
    
    <p><strong>Results:</strong></p>
    <ul>
        <li><code>purchasePrice</code> error: "Der angegebene Einkaufspreis ist ungültig"</li>
        <li><code>salesTax</code> error: "Der angegebene Umsatzsteuer ist ungültig"</li>
    </ul>

    <h6>Benefits</h6>
    <ul>
        <li><strong>Reusable validators</strong> - Same validation logic, different contexts</li>
        <li><strong>Meaningful messages</strong> - Field-specific labels in error messages</li>
        <li><strong>Internationalization</strong> - Labels defined per locale in properties files</li>
        <li><strong>Custom variables</strong> - Validators can add additional variables (e.g., <code>${max}</code>, <code>${country}</code>)</li>
    </ul>

    <h5>Nested Object Validation</h5>
    <p>Validate nested objects using <code>@Valid</code>:</p>
    <xis:raw>
        <pre><code>public class OrderForm {
    
    @Valid
    @Mandatory
    private CustomerInfo customer;
    
    @Valid
    @Mandatory
    private AddressInfo shippingAddress;
}

public class CustomerInfo {
    
    @Mandatory
    private String name;
    
    @Email
    private String email;
}</code></pre>
        <p>Errors for nested fields use dot notation: <code>${errors['order.customer.name']}</code></p>
    </xis:raw>

    <h5>Validation Messages</h5>
    <p>XIS uses message keys for validation error messages, enabling internationalization and customization.</p>

    <h6>Message Properties Files</h6>
    <xis:raw>
        <p>XIS provides default validation messages in:</p>
        <ul>
            <li><code>default-messages.properties</code> - Default English messages</li>
            <li><code>default-messages_de.properties</code> - German messages</li>
            <li><code>default-messages_en.properties</code> - English messages</li>
        </ul>
        <p>Override these messages by creating your own files:</p>
        <ul>
            <li><code>messages.properties</code> - Your default messages</li>
            <li><code>messages_de.properties</code> - Your German messages</li>
            <li><code>messages_en.properties</code> - Your English messages</li>
        </ul>
        <p><strong>Example messages.properties:</strong></p>
        <pre><code># XIS validation messages
validation.mandatory.notNull=Pflichtfeld
validation.email.invalid=Ungültige E-Mail-Adresse
validation.minLength.tooShort=Mindestlänge ist {min} Zeichen

# Custom validation messages with ${label} placeholder
validation.iban.invalid=Die angegebene ${label} ist keine gültige IBAN
validation.iban.checksum=Ungültige Prüfsumme für ${label}
validation.phone.format=Ungültiges Telefonnummernformat für ${label} in {country}</code></pre>
    </xis:raw>

    <h5>Custom Validation Annotations</h5>
    <p>Create custom validation annotations for reusable validation logic. XIS follows the Bean Validation standard 
        (JSR-380) and provides access to <code>UserContext</code> for locale-aware validation.</p>

    <h6>Define the Annotation</h6>
    <xis:raw>
        <pre><code>import java.lang.annotation.*;

@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface Iban {
    
    // Message key for error message lookup in properties files
    // Message can use ${label} placeholder for @LabelKey values
    String message() default "validation.iban.invalid";
    
    // Validator class - XIS will search in context or instantiate
    Class<?> validator() default IbanValidator.class;
}</code></pre>
        <p><strong>Message Properties Example:</strong></p>
        <pre><code># messages_de.properties
validation.iban.invalid=Die angegebene ${label} ist keine gültige IBAN
validation.iban.checksum=Ungültige Prüfsumme für ${label}

# Default label if no @LabelKey specified
iban=IBAN

# Custom labels via @LabelKey
accountNumber=Kontonummer
paymentAccount=Zahlungskonto</code></pre>
    </xis:raw>

    <h6>Implement the Validator</h6>
    <xis:raw>
        <pre><code>import one.xis.context.UserContext;

public class IbanValidator {
    
    private UserContext userContext;
    
    // XIS automatically injects UserContext if available in context,
    // otherwise creates validator instance with default constructor
    public IbanValidator(UserContext userContext) {
        this.userContext = userContext;
    }
    
    public boolean isValid(String value) {
        // Null values are valid unless @Mandatory is also used
        if (value == null || value.isEmpty()) {
            return true;
        }
        
        // Remove spaces and convert to uppercase
        String iban = value.replaceAll("\\s", "").toUpperCase();
        
        // Basic length check (15-34 characters)
        if (iban.length() &lt; 15 || iban.length() &gt; 34) {
            return false;
        }
        
        // Country-specific validation using UserContext
        String countryCode = iban.substring(0, 2);
        String userCountry = userContext.getCountry();
        
        // Example: Validate length based on country
        if ("DE".equals(countryCode) && iban.length() != 22) {
            return false;
        }
        if ("AT".equals(countryCode) && iban.length() != 20) {
            return false;
        }
        
        // Perform checksum validation (mod 97)
        return validateChecksum(iban);
    }
    
    private boolean validateChecksum(String iban) {
        // Move first 4 characters to end
        String rearranged = iban.substring(4) + iban.substring(0, 4);
        
        // Replace letters with numbers (A=10, B=11, ..., Z=35)
        StringBuilder numeric = new StringBuilder();
        for (char c : rearranged.toCharArray()) {
            if (Character.isDigit(c)) {
                numeric.append(c);
            } else {
                numeric.append(c - 'A' + 10);
            }
        }
        
        // Calculate mod 97
        return mod97(numeric.toString()) == 1;
    }
    
    private int mod97(String number) {
        int result = 0;
        for (char digit : number.toCharArray()) {
            result = (result * 10 + (digit - '0')) % 97;
        }
        return result;
    }
}</code></pre>
    </xis:raw>

    <h6>Usage in Form</h6>
    <xis:raw>
        <pre><code>public class PaymentForm {
    
    @Mandatory  // Makes null check fail - required for non-null values
    @Iban       // Uses default label "iban" from properties
    private String iban;
    
    @Mandatory
    @Iban
    @LabelKey("paymentAccount")  // Uses custom label "paymentAccount" from properties
    private String secondaryAccount;
    
    @Mandatory
    private String accountHolder;
}</code></pre>
        <p><strong>Important:</strong> Without <code>@Mandatory</code>, a null value would be considered valid. 
            The <code>@Iban</code> validator only validates non-null values.</p>
        <p><strong>Error Messages:</strong></p>
        <ul>
            <li><code>iban</code> error: "Die angegebene IBAN ist keine gültige IBAN"</li>
            <li><code>secondaryAccount</code> error: "Die angegebene Zahlungskonto ist keine gültige IBAN"</li>
        </ul>
        <p><strong>Template:</strong></p>
        <pre><code>&lt;div&gt;
    &lt;label&gt;IBAN&lt;/label&gt;
    &lt;input type="text" name="payment.iban" value="${payment.iban}"/&gt;
    &lt;span class="error" xis:if="${errors['payment.iban']}"&gt;
        ${errors['payment.iban']}
    &lt;/span&gt;
&lt;/div&gt;</code></pre>
    </xis:raw>

    <h6>Usage on Action Parameters</h6>
    <xis:raw>
        <pre><code>@Action
void addPaymentMethod(
    @ActionParameter("iban") 
    @Iban 
    String iban
) {
    paymentService.addAccount(iban);
}</code></pre>
    </xis:raw>

    <h5>@Mandatory - Special Null Handling</h5>
    <p><code>@Mandatory</code> is a XIS-specific annotation that changes null-value behavior:</p>
    <xis:raw>
        <ul>
            <li><strong>Without @Mandatory:</strong> If a value is null, other validators are NOT executed (no error)</li>
            <li><strong>With @Mandatory:</strong> Null values cause a validation error</li>
            <li><strong>Includes:</strong> Validates not null, not empty, and not blank (whitespace)</li>
        </ul>
        <pre><code>// Without @Mandatory: null is valid, but if provided must be valid email
@Email
private String email;

// With @Mandatory: null causes error, AND if provided must be valid email
@Mandatory
@Email
private String email;</code></pre>
        <p><code>@Mandatory</code> is a XIS-specific annotation that validates not null, not empty, and not blank (whitespace only).</p>
    </xis:raw>

    <h5>@LabelKey - Context-Specific Error Messages</h5>
    <p><code>@LabelKey</code> allows you to use the same validation annotation with different field labels in error messages:</p>
    <xis:raw>
        <pre><code>// In your form class
public class CustomerForm {
    
    @Mandatory
    @Email
    private String email;
    
    @Mandatory
    @Email
    @LabelKey("email2")  // Custom label key for this field
    private String secondEmail;
    
    @Mandatory
    @Money
    @LabelKey("purchasePrice")
    private BigDecimal price;
    
    @Mandatory
    @Money
    @LabelKey("salesTax")
    private BigDecimal tax;
}</code></pre>
        <p><strong>Messages Properties (messages_de.properties):</strong></p>
        <pre><code># Default labels
email=E-Mail-Adresse

# Custom labels via @LabelKey
email2=Zweite E-Mail-Adresse
purchasePrice=Einkaufspreis
salesTax=Umsatzsteuer

# Validation message template uses ${label} placeholder
validation.email.invalid=Die angegebene ${label} ist keine gültige E-Mail
validation.money.invalid=Der angegebene ${label} ist ungültig</code></pre>
        <p><strong>Result:</strong> Error messages adapt to the context:</p>
        <ul>
            <li><code>email</code> field error: "Die angegebene E-Mail-Adresse ist keine gültige E-Mail"</li>
            <li><code>secondEmail</code> field error: "Die angegebene Zweite E-Mail-Adresse ist keine gültige E-Mail"</li>
            <li><code>price</code> field error: "Der angegebene Einkaufspreis ist ungültig"</li>
            <li><code>tax</code> field error: "Der angegebene Umsatzsteuer ist ungültig"</li>
        </ul>
        <p><strong>Benefits:</strong></p>
        <ul>
            <li>Reuse validation annotations across different contexts</li>
            <li>Provide meaningful, context-specific error messages</li>
            <li>Support for internationalization (separate files per locale)</li>
            <li>Validators can add their own variables to message templates</li>
        </ul>
    </xis:raw>

    <h5>UserContext in Validators</h5>
    <p>The <code>UserContext</code> provides access to user-specific information for context-aware validation:</p>
    <xis:raw>
        <ul>
            <li><strong>userContext.getLocale():</strong> User's locale for locale-specific validation</li>
            <li><strong>userContext.getCountry():</strong> User's country code (e.g., "DE", "AT", "US")</li>
            <li><strong>userContext.getLanguage():</strong> User's language code</li>
            <li><strong>userContext.getTimeZone():</strong> User's time zone</li>
        </ul>
        <p>This enables validators to adapt behavior based on the user's context, such as validating phone numbers 
            with country-specific formats or checking postal codes against the user's country.</p>
        <p><strong>Validator Instantiation:</strong> XIS first searches for the validator in the application context 
            (Spring/Micronaut). If not found, it creates a new instance using the constructor. Use constructor injection 
            for dependencies like <code>UserContext</code>.</p>
    </xis:raw>

    <h6>Example: Country-Specific Phone Validation</h6>
    <xis:raw>
        <pre><code>@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface PhoneNumber {
    String message() default "validation.phone.format";
    Class<?> validator() default PhoneNumberValidator.class;
}

public class PhoneNumberValidator {
    
    private UserContext userContext;
    
    public PhoneNumberValidator(UserContext userContext) {
        this.userContext = userContext;
    }
    
    public boolean isValid(String value) {
        if (value == null || value.isEmpty()) {
            return true;
        }
        
        String country = userContext.getCountry();
        
        return switch (country) {
            case "DE" -&gt; value.matches("^\\+49[1-9]\\d{1,14}$");
            case "AT" -&gt; value.matches("^\\+43[1-9]\\d{1,13}$");
            case "US" -&gt; value.matches("^\\+1[2-9]\\d{9}$");
            default -&gt; value.matches("^\\+[1-9]\\d{1,14}$"); // Generic
        };
    }
}</code></pre>
    </xis:raw>

    <h5>Validating Complex Objects</h5>
    <p>Custom validators can validate entire objects, not just single values:</p>
    <xis:raw>
        <pre><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface ValidDateRange {
    String message() default "validation.daterange.invalid";
    Class<?> validator() default DateRangeValidator.class;
}

public class DateRangeValidator {
    
    public boolean isValid(EventForm form) {
        if (form.getStartDate() == null || form.getEndDate() == null) {
            return true;
        }
        return form.getEndDate().isAfter(form.getStartDate());
    }
}

// Usage on class level
@ValidDateRange
public class EventForm {
    private LocalDate startDate;
    private LocalDate endDate;
}</code></pre>
    </xis:raw>

    <h5>Programmatic Custom Validation</h5>
    <p>For validation that requires database access or complex business logic, validate programmatically in action methods:</p>
    <xis:raw>
        <pre><code>@FormData("user")
@Validate
UserForm userForm;

private Map&lt;String, String&gt; customErrors;

@Action
void saveUser() {
    // Annotation validation already passed
    
    // Add custom business logic validation
    if (userService.emailExists(userForm.getEmail())) {
        customErrors = Map.of("user.email", "Email already registered");
        return; // Stay on form
    }
    
    userService.save(userForm);
}

@ModelData("errors")
Map&lt;String, String&gt; getErrors() {
    return customErrors;
}</code></pre>
    </xis:raw>

    <h5>Validation Scenarios</h5>
    <p>Use different validation for create vs. update scenarios:</p>
    <xis:raw>
        <pre><code>public class UserForm {
    
    private String id;  // Only required for updates
    
    @Mandatory
    private String name;
    
    @Mandatory
    @Email
    private String email;
}

// In controller - different validation based on scenario
@FormData("user")
@Validate
UserForm userForm;

@Action
void createUser() {
    // id can be null for creation
    userService.create(userForm);
}

@Action
void updateUser() {
    if (userForm.getId() == null) {
        // Manual validation for update scenario
        errors.put("user.id", "ID is required for updates");
        return;
    }
    userService.update(userForm);
}</code></pre>
    </xis:raw>

    <h5>Validation Error Styling</h5>
    <p>XIS automatically adds CSS classes to form fields with errors. Use <code>xis-error</code> class for styling:</p>
    <xis:raw>
        <pre><code>&lt;style&gt;
    .xis-error {
        border-color: red;
        background-color: #fff0f0;
    }
    .error {
        color: red;
        font-size: 0.9em;
    }
&lt;/style&gt;</code></pre>
    </xis:raw>

    <div class="warning">
        <strong>Security:</strong> Always validate on the server side. Client-side validation (HTML5 attributes) 
        provides user experience improvements but can be bypassed. XIS validation happens server-side and is 
        security-safe.
    </div>
</xis:template>
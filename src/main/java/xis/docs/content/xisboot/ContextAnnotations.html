<xis:template xmlns:xis="http://www.w3.org/1999/XSL/Transform">
    <h3>${chapterHeadline}</h3>

    <div class="alert alert-info" role="alert">
        <strong>‚ÑπÔ∏è Annotation Changes Coming</strong><br/>
        Currently, XIS uses prefixed annotations like <code>@Component</code>, <code>@XISService</code>, etc.
        In a future version, these will be simplified to <code>@Component</code>, <code>@Service</code>, etc.
        This documentation shows the future naming convention.
    </div>

    <p>XIS Boot provides a lightweight dependency injection and component scanning system. Components are
        registered and managed by the XIS context, similar to Spring or Micronaut but without the framework
        overhead.</p>

    <h5>Component Annotations</h5>

    <h6>@Component</h6>
    <p>Mark a class as a managed component. XIS will create a single instance (singleton) and make it available for
        injection:</p>

    <pre><code class="language-java">@Component
public class UserService {
    public User findById(String id) {
        // Business logic
    }
}</code></pre>

    <h6>@Service</h6>
    <p>Specialized <code>@Component</code> for service layer classes:</p>

    <pre><code class="language-java">@Service
public class EmailService {
    public void sendEmail(String to, String subject, String body) {
        // Email sending logic
    }
}</code></pre>

    <h5>Dependency Injection</h5>
    <p>Inject components into pages, widgets, or other components using constructor injection:</p>

    <pre><code class="language-java">@Page("/users.html")
public class UsersPage {
    private final UserService userService;
    
    public UsersPage(UserService userService) {
        this.userService = userService;
    }
    
    @ModelData("users")
    public List&lt;User&gt; getUsers() {
        return userService.findAll();
    }
}</code></pre>

    <h6>Field Injection with @Inject</h6>
    <p>Alternatively, you can use field injection with the <code>@Inject</code> annotation:</p>

    <pre><code class="language-java">@Page("/users.html")
public class UsersPage {
    @Inject
    private UserService userService;
    
    @ModelData("users")
    public List&lt;User&gt; getUsers() {
        return userService.findAll();
    }
}</code></pre>

    <p>If you have more then one bean of the same base type, you can use a collection or array:</p>

    <pre><code class="language-java">@Page("/users.html")
public class UsersPage {
    @Inject
    private Collection&lt;Datasource&gt; dataSources;</code></pre>

    <p>The attribute <code>annotatedWith</code> allows to inject beans by their annotations:</p>

    <pre><code class="language-java">@Page("/users.html")
public class UsersPage {
    @Inject(annotatedWith = Page.class)
    private Collection&lt;Object&gt; pages;</code></pre>

    <p><strong>Note:</strong> Constructor injection is generally preferred over field injection for better testability.
    </p>

    <h5>Lifecycle Methods</h5>

    <h6>@Init</h6>
    <p>Methods annotated with <code>@Init</code> are called after the component is constructed and all dependencies
        are injected. This is useful for initialization logic that requires dependencies:</p>

    <pre><code class="language-java">@Component
public class DatabaseService {
    private final ConfigService configService;
    private Connection connection;
    
    public DatabaseService(ConfigService configService) {
        this.configService = configService;
    }
    
    @Init
    public void initialize() {
        // Called after constructor and dependency injection
        this.connection = createConnection(configService.getDatabaseUrl());
    }
}</code></pre>

    <h5>Bean Factory Methods</h5>

    <h6>@Bean</h6>
    <p>Methods annotated with <code>@Bean</code> act as factory methods that create and register components.
        This is useful when you need programmatic control over component creation:</p>

    <pre><code class="language-java">@Component
public class AppConfiguration {
    
    @Bean
    public DataSource createDataSource(Config config) {
        return new DataSource(config.getDbUrl(), config.getDbUser(), config.getDbPassword());
    }

}</code></pre>

    <p>The returned instances from <code>@Bean</code> methods are registered as singletons in the context and
        can be injected into other components.</p>

    <div class="info">
        Every singleton can be used as a method parameter in a <code>@Bean</code> or <code>@BInit</code>method as long
        the dependency graph has no cycles.
    </div>

    <h5>Event Handling</h5>

    <h6>@EventListener</h6>
    <p>Methods annotated with <code>@EventListener</code> are invoked when application events are emitted.
        The method parameter type determines which events it receives:</p>

    <pre><code class="language-java">@Component
public class UserActivityLogger {
    
    @EventListener
    public void onUserLogin(UserLoginEvent event) {
        log.info("User logged in: " + event.getUserId());
    }
    
    @EventListener
    public void onUserLogout(UserLogoutEvent event) {
        log.info("User logged out: " + event.getUserId());
    }
}</code></pre>

    <p>To emit events, inject <code>EventEmitter</code> and call <code>emitEvent()</code>:</p>

    <pre><code class="language-java">@Service
public class AuthService {
    private final EventEmitter eventEmitter;
    
    public AuthService(EventEmitter eventEmitter) {
        this.eventEmitter = eventEmitter;
    }
    
    public void login(String userId) {
        // ... authentication logic ...
        eventEmitter.emitEvent(new UserLoginEvent(userId));
    }
}</code></pre>

    <h5>Component Scope</h5>
    <p>All components in XIS Boot are singletons (one instance per application). This is the only supported scope.
        There is no special annotation required - all components annotated with <code>@Component</code> or
        <code>@Service</code> are automatically application-scoped singletons.</p>

    <h5>Component Scanning</h5>
    <p>XIS Boot automatically scans for components in the same package as your main class and all sub-packages.</p>

    <h5>Current vs Future Annotations</h5>
    <p>Mapping of current to future annotation names:</p>
    <table class="table table-sm">
        <thead>
        <tr>
            <th>Current</th>
            <th>Future</th>
            <th>Purpose</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td><code>@Component</code></td>
            <td><code>@Component</code></td>
            <td>Generic managed component</td>
        </tr>
        <tr>
            <td><code>@XISService</code></td>
            <td><code>@Service</code></td>
            <td>Service layer component</td>
        </tr>
        </tbody>
    </table>
    
    <h5>Spring Framework Compatibility</h5>
    <p>XIS Boot is designed to be significantly simpler and more lightweight than the Spring Framework application
        context.
        Consequently, many Spring features and annotations are not supported. However, to ease migration from
        Spring-based
        applications, XIS Boot recognizes some commonly used Spring annotations.</p>

    <div class="alert alert-warning" role="alert">
        <strong>‚ö†Ô∏è Limited Support</strong><br/>
        XIS Boot does not aim to be a complete Spring replacement. Only a subset of Spring annotations is supported.
        For the complete and current list of supported Spring annotations, please refer to the JavaDoc of the
        <code>one.xis.boot.SpringCompatibility</code> class in the <code>xis-boot</code> module.
    </div>

    <p>Examples of supported Spring annotations include:</p>
    <ul>
        <li>Component stereotypes: <code>@Component</code>, <code>@Service</code></li>
        <li>Lifecycle callbacks: <code>@PostConstruct</code> (javax and jakarta)</li>
        <li>Dependency injection: <code>@Autowired</code>, <code>@Inject</code></li>
        <li>Factory methods: <code>@Bean</code></li>
    </ul>

    <p>To see the exact list of supported annotations and stay up-to-date with any changes, always check the
        <code>SpringCompatibility</code> class in the source code.</p>

    <div class="alert alert-info" role="alert">
        <strong>üí° Recommendation</strong><br/>
        While Spring annotation support helps avoid costly refactoring when migrating existing code, <strong>this is not
        the recommended approach</strong> for new XIS Boot applications. Using Spring annotations can lead to
        misunderstandings about which features are actually supported by XIS Boot, as the framework is intentionally
        much simpler than Spring. <strong>For new code, always use the native XIS context annotations</strong>
        (<code>@Component</code>, <code>@XISService</code>, etc.) to avoid confusion and ensure clear expectations.
    </div>
</xis:template>

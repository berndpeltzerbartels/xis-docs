<xis:template xmlns:xis="http://www.w3.org/1999/XSL/Transform">
    <h3>${chapterHeadline}</h3>
    <p>
        XIS provides a set of annotations for controller methods that define how methods interact with the 
        framework, handle user actions, and manage data. These annotations are the building blocks for creating 
        interactive web applications with clear separation of concerns.
    </p>
    <p>
        <strong>Note:</strong> For class-level annotations like <code>@WelcomePage</code>, <code>@RefreshOnUpdateEvents</code>, 
        and <code>@Roles</code> applied to classes, see the <a href="#" xis:page="ClassAnnotations">Class Annotations</a> section.
    </p>

    <h5>@ModelData</h5>
    <p>
        Provides data to templates. The method's return value becomes available in the template using the method 
        name as the key, or an explicitly specified key via the annotation parameter.
    </p>
    <pre><code>@ModelData
List&lt;User&gt; users() $​{
    return userService.findAll();
}

@ModelData("currentUser")
User getLoggedInUser() $​{
    return securityContext.getCurrentUser();
}</code></pre>
    <p>In templates, access the data using the key:</p>
    <pre><code>&lt;h1&gt;Welcome $​{currentUser.name}&lt;/h1&gt;
&lt;ul xis:foreach="user:$​{users}"&gt;
    &lt;li&gt;$​{user.name} ($​{user.email})&lt;/li&gt;
&lt;/ul&gt;</code></pre>

    <h5>@SharedValue</h5>
    <p>
        Shares values between controller methods within a single request. When a method annotated with 
        <code>@SharedValue</code> executes, its return value is cached and made available to other methods 
        that request it via the <code>@SharedValue</code> parameter annotation.
    </p>
    <p>
        <strong>Use Case:</strong> Avoid redundant database queries or expensive computations when multiple 
        methods need the same data. For example, if both a <code>@ModelData</code> method and a 
        <code>@PageTitle</code> method need to load the same product from the database, using 
        <code>@SharedValue</code> ensures the database is queried only once.
    </p>
    <p>
        <strong>Behavior:</strong>
    </p>
    <ul>
        <li><strong>On methods:</strong> The return value is <strong>cached</strong> in the request context under the specified key</li>
        <li><strong>As parameter:</strong> The cached value is <strong>injected</strong> from the request context</li>
        <li><strong>Scope:</strong> Values are only available within the current request - they do not persist across requests</li>
    </ul>
    <pre><code class="language-java">// Without @SharedValue: Database queried twice (inefficient)
@ModelData("product")
Product getProduct(@QueryParameter("productId") String productId) $​{
    return database.loadProduct(productId); // 1st DB query
}

@PageTitle
String getTitle(@QueryParameter("productId") String productId) $​{
    Product p = database.loadProduct(productId); // 2nd DB query - REDUNDANT!
    return p.getName();
}

// With @SharedValue: Database queried once (efficient)
@SharedValue("product")
Product loadProduct(@QueryParameter("productId") String productId) $​{
    return database.loadProduct(productId); // Only 1 DB query
}

@ModelData("product")
Product getProduct(@SharedValue("product") Product product) $​{
    return product; // Reuses cached value
}

@PageTitle
String getTitle(@SharedValue("product") Product product) $​{
    return product.getName(); // Reuses cached value
}</code></pre>
    <p>
        See <a href="#" xis:page="ParameterAnnotations">Parameter Annotations</a> for details on using 
        <code>@SharedValue</code> as a parameter.
    </p>

    <h5>@Action</h5>
    <p>
        Handles user interactions such as button clicks, link navigation, or form submissions. Actions can return 
        different types to control navigation: <code>PageResponse</code>, <code>WidgetResponse</code>, 
        <code>Class&lt;?&gt;</code> for navigation, or <code>void</code> to stay on the current page.
    </p>
    <pre><code>@Action("delete")
void deleteProduct(@ActionParameter("productId") String productId) $​{
    productService.delete(productId);
    // Returns void - stays on current page
}

@Action("viewDetails")
Class&lt;?&gt; viewProductDetails(@ActionParameter("productId") String productId) $​{
    return ProductDetailsPage.class; // Navigate to different page
}

@Action("updateWidget")
WidgetResponse refreshContent() $​{
    return new WidgetResponse(UpdatedContentWidget.class);
}</code></pre>
    <p><strong>Trigger Actions via Links:</strong> Use <code>xis:action</code> on <code>&lt;a&gt;</code> tags 
        to execute controller methods when users click links:</p>
    <pre><code>@Action
void markAsRead() $​{
    message.read = true;
    messageService.update(message);
}</code></pre>
    <p>Template:</p>
    <pre><code>&lt;a xis:action="markAsRead"&gt;Mark as read&lt;/a&gt;

&lt;!-- With parameters --&gt;
&lt;a xis:action="deleteItem"&gt;
    &lt;xis:parameter name="itemId" value="$​{item.id}"/&gt;
    Delete
&lt;/a&gt;</code></pre>
    <p>See the <a href="#" xis:page="Lifecycle">Lifecycle</a> chapter for complete flow diagrams.</p>

    <h5>@FormData</h5>
    <p>
        Binds form input data to method parameters with automatic type conversion and validation support. 
        Can be used both as a method annotation and as a parameter annotation.
    </p>
    <pre><code>@Action("save")
void saveUser(@FormData("user") User user) $​{
    userService.save(user);
}</code></pre>
    <p>Used with form binding in templates:</p>
    <pre><code>&lt;form xis:binding="user"&gt;
    &lt;input xis:binding="name" type="text" name="name"/&gt;
    &lt;input xis:binding="email" type="email" name="email"/&gt;
    &lt;button xis:action="save" type="submit"&gt;Save&lt;/button&gt;
&lt;/form&gt;</code></pre>

    <h5>@SharedValue</h5>
    <p>
        Injects request-scoped data that is available throughout the current request lifecycle. XIS automatically 
        makes return values of <code>@ModelData</code> methods available in the request scope, allowing other 
        methods to access this data without recomputing it.
    </p>
    <pre><code>@ModelData("user")
User loadUser() $​{
    return userService.getCurrentUser(); // Computed once
}

@ModelData("permissions")
List&lt;Permission&gt; loadPermissions(@SharedValue("user") User user) $​{
    // User data injected from request scope
    return permissionService.getPermissionsForUser(user.getId());
}

@Action("updateProfile")
void updateProfile(@FormData("profile") UserProfile profile,
                  @SharedValue("user") User currentUser) $​{
    if (currentUser.getId().equals(profile.getUserId())) $​{
        userService.updateProfile(profile);
    }
}</code></pre>

    <h5>Client-Side Storage: @LocalStorage, @SessionStorage, @ClientStorage</h5>
    <p>
        XIS provides three storage mechanisms for managing client-side state. All work similarly but differ in 
        persistence and location:
    </p>
    <table>
        <thead>
            <tr>
                <th>Annotation</th>
                <th>Storage Location</th>
                <th>Persistence</th>
                <th>Use Cases</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>@LocalStorage</code></td>
                <td>Browser (localStorage)</td>
                <td>Permanent (until cleared)</td>
                <td>User preferences, theme, language</td>
            </tr>
            <tr>
                <td><code>@SessionStorage</code></td>
                <td>Browser (sessionStorage)</td>
                <td>Tab session only</td>
                <td>Current tab state, filters, pagination</td>
            </tr>
            <tr>
                <td><code>@ClientStorage</code></td>
                <td>Server-side</td>
                <td>Client session</td>
                <td>Sensitive data, large datasets</td>
            </tr>
        </tbody>
    </table>

    <h6>@LocalStorage</h6>
    <p>
        Persistent browser storage that survives page reloads and browser restarts. Perfect for user preferences 
        and long-term settings.
    </p>
    <p>
        <strong>Behavior:</strong>
    </p>
    <ul>
        <li><strong>On methods:</strong> The return value is <strong>always written</strong> to localStorage</li>
        <li><strong>As parameter:</strong> The value is <strong>read from</strong> localStorage</li>
        <li><strong>In templates:</strong> Access with <code>localStorage.key</code></li>
        <li><strong>Updates:</strong> Changes do not automatically trigger updates in other components. Use 
            <code>@Action(updateEventKeys = {...})</code> to notify other widgets via <code>@RefreshOnUpdateEvents</code></li>
    </ul>
    <pre><code>// Method: Writes return value to localStorage
@LocalStorage("userTheme")
String getUserTheme() $​{
    return "dark"; // This value is written to localStorage
}

// Parameter: Reads current value from localStorage
@Action("logTheme")
void logTheme(@LocalStorage("userTheme") String currentTheme) $​{
    System.out.println("Current theme: " + currentTheme);
}

// Action: Updates localStorage and notifies other widgets
@Action(value = "changeTheme", updateEventKeys = {"theme-changed"})
@LocalStorage("userTheme") // Return value is saved to localStorage
String changeTheme(@ActionParameter("newTheme") String newTheme) {
    return newTheme; // Saved to localStorage, emits "theme-changed" event
}</code></pre>
    <p>In templates, access with the <code>localStorage.</code> prefix:</p>
    <pre><code>&lt;body class="theme-${localStorage.userTheme}"&gt;
    &lt;button xis:action="changeTheme"&gt;
        &lt;xis:parameter name="newTheme" value="light"/&gt;
        Switch to Light
    &lt;/button&gt;
&lt;/body&gt;</code></pre>

    <h6>@SessionStorage</h6>
    <p>
        Tab-specific storage that persists only within the current browser tab/window. Cleared when tab closes. 
        Ideal for tab-specific UI state.
    </p>
    <pre><code>// Initialize default value
@SessionStorage("selectedTab")
String getSelectedTab() $​{
    return "dashboard";
}

// Update and emit event
@Action(value = "selectTab", updateEventKeys = $​{"tab-changed"})
@SessionStorage("selectedTab")
String selectTab(@ActionParameter("tab") String tab) $​{
    return tab;
}</code></pre>
    <p>Template access: <code>${sessionStorage.selectedTab}</code></p>

    <h6>@ClientStorage</h6>
    <p>
        Server-side storage associated with the client session. Use for sensitive data or large datasets that 
        shouldn't be sent to the browser.
    </p>
    <pre><code>@ClientStorage("userCart")
ShoppingCart cart;

@Action
void addToCart(@ActionParameter("productId") String productId) $​{
    cart.addItem(productId);  // Stored server-side
}</code></pre>
    <p>Template access: <code>${clientStorage.userCart}</code></p>
    <p>Other widgets can reload when tab selection changes:</p>
    <pre><code>@Widget
@RefreshOnUpdateEvents("tab-changed")
class TabContentWidget $​{
    // This widget will reload when "tab-changed" event is emitted

}</code></pre>

    <h5>@Roles</h5>
    <p>
        Provides role-based access control for methods and classes. Works with security frameworks to enforce 
        authorization. Can be applied at class level (affects all methods) or method level (specific actions).
    </p>
    <pre><code>@Page("/admin-panel.html")
@Roles($​{"ADMIN", "MODERATOR"}) // Class-level
class AdminPanelPage $​{
    
    @ModelData
    List&lt;Product&gt; getAllProducts() $​{
        return productService.findAll(); // Inherits class roles
    }
    
    @Action("deleteProduct")
    @Roles("ADMIN") // Only ADMIN can delete
    void deleteProduct(@ActionParameter("productId") String productId) $​{
        productService.delete(productId);
    }
    
    @Action("archiveProduct")
    @Roles($​{"ADMIN", "EDITOR"}) // Multiple roles
    void archiveProduct(@ActionParameter("productId") String productId) $​{
        productService.archive(productId);
    }
}</code></pre>

    <p>XIS automatically makes the return values of @ModelData methods available in the request scope using the same key. You can then inject this data into other methods using @SharedValue. This creates a clean data flow where expensive operations (like database queries) only happen once per request, and the results are shared across all methods that need them.</p>

    <h6>@Roles</h6>
    <p>Provides role-based access control for methods and classes. Used in conjunction with security frameworks to enforce authorization.</p>
    <pre><code class="language-java"><xis:raw>@Page("/admin-panel.html")
@Roles(&#123;"ADMIN", "MODERATOR"}) // Class-level: entire page requires these roles
class AdminPanelPage &#123;
    
    @ModelData
    List&lt;User&gt; getAllUsers() &#123;
        return productService.findAll(); // Inherits class-level roles
    }
    
    @Action("deleteProduct")
    @Roles("ADMIN") // Method-level: only ADMIN can delete products
    void deleteProduct(@ActionParameter("productId") String productId) &#123;
        productService.delete(productId);
    }
    
    @Action("archiveProduct") 
    @Roles(&#123;"ADMIN", "EDITOR"}) // Multiple roles allowed
    void archiveProduct(@ActionParameter("productId") String productId) &#123;
        productService.archive(productId);
    }
}</xis:raw></code></pre>

    <h6>@Refresh</h6>
    <p>Triggers a refresh of specified controllers after method execution. Useful for updating related components when data changes.</p>
    <pre><code class="language-java"><xis:raw>@Widget
class UserListWidget &#123;
    @ModelData
    List&lt;User&gt; getUsers() &#123;
        return userService.findAll();
    }
}

@Widget  
class UserFormWidget &#123;
    @Action("saveUser")
    @Refresh(controllerCLass = UserListWidget.class) // Refresh user list after save
    void saveProduct(@FormData("product") Product product) &#123;
        productService.save(product);
    }
    
    @Action("deleteProduct")
    @Refresh(controllerName = "productListWidget") // Alternative: refresh by name
    void deleteProduct(@ActionParameter("productId") String productId) &#123;
        productService.delete(productId);
    }
}</xis:raw></code></pre>

    <h6>@LocalDatabase</h6>
    <p>Accesses the browser's IndexedDB for client-side structured data storage. Perfect for offline functionality and large datasets that exceed localStorage limits.</p>
    <pre><code class="language-java"><xis:raw>@Widget
class OfflineDataWidget &#123;
    @LocalDatabase("userData")
    String getUserData() &#123;
        return "&#123;}"; // Default JSON value
    }
    
    @Action("saveOfflineData")
    void saveData(@FormData("data") UserData data,
                  @LocalDatabase("userData") String existingData) &#123;
        // Existing data is automatically loaded from IndexedDB
        // New data will be automatically saved
        logger.info("Previous data: " + existingData);
    }
}</xis:raw></code></pre>
    <p>In templates, localDatabase values are accessed with the <code>localDatabase.&lt;property&gt;</code> prefix:</p>
    <pre><code class="language-html"><xis:raw>&lt;div xis:if="&#036;&#123;localDatabase.userData != '&#123;}'}"&gt;
    &lt;h3&gt;Offline Data Available&lt;/h3&gt;
    &lt;p&gt;Data: &#036;&#123;localDatabase.userData}&lt;/p&gt;
&lt;/div&gt;
&lt;div xis:if="&#036;&#123;localDatabase.userData == '&#123;}'}"&gt;
    &lt;p&gt;No offline data found&lt;/p&gt;
&lt;/div&gt;</xis:raw></code></pre>

    <p>XIS provides comprehensive method annotations for everything from form data to reactive state management.</p>

    <h6>@ModelData</h6>
    <p>Provides data to templates. The key defaults to the method name or can be specified explicitly.</p>
    <pre><code class="language-java"><xis:raw>@ModelData
List&lt;User&gt; users() &#123;
    return userService.findAll();
}

@ModelData("currentUser")
User getLoggedInUser() &#123;
    return securityContext.getCurrentUser();
}</xis:raw></code></pre>
    <p>In templates, access the data using the key:</p>
    <pre><code class="language-html"><xis:raw>&lt;!DOCTYPE html&gt;
&lt;html xmlns:xis="https://xis.one/xsd"&gt;
&lt;body&gt;
    &lt;h1&gt;Welcome &#036;&#123;currentUser.name}&lt;/h1&gt;
    &lt;ul&gt;
        &lt;div xis:foreach="user:&#036;&#123;users}"&gt;
            &lt;li&gt;&#036;&#123;user.name} (&#036;&#123;user.email})&lt;/li&gt;
        &lt;/div&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</xis:raw></code></pre>

    <h6>@FormData</h6>
    <p>Binds form input data to method parameters with automatic validation support.</p>
    <pre><code class="language-java"><xis:raw>@Action("save")
void saveUser(@FormData("user") User user) &#123;
    userService.save(user);
}</xis:raw></code></pre>
    <p>Used with form binding in templates:</p>
    <pre><code class="language-html"><xis:raw>&lt;form xis:binding="user"&gt;
    &lt;input xis:binding="name" type="text" name="name"&gt;
    &lt;input xis:binding="email" type="email" name="email"&gt;
    &lt;button xis:action="save" type="submit"&gt;Save User&lt;/button&gt;
&lt;/form&gt;</xis:raw></code></pre>

    <h6>@Action</h6>
    <p>Handles user interactions like button clicks or form submissions.</p>
    <pre><code class="language-java"><xis:raw>@Action("delete")
void deleteProduct(@ActionParameter("productId") String productId) &#123;
    productService.delete(productId);
}</xis:raw></code></pre>

    <h6>@GlobalVariable</h6>
    <p>Provides reactive global variables that are shared across all components during request processing. These
        variables are automatically updated in all templates when they change - perfect for sharing data between widgets
        on the same page.</p>
    <pre><code class="language-java"><xis:raw>// UserHeaderWidget.java
@Widget
class UserHeaderWidget &#123;
    @GlobalVariable("currentUserName")
    String getCurrentUserName() &#123;
        return securityContext.getCurrentUser().getName();
    }
}

// UserProfileWidget.java
@Widget
class UserProfileWidget &#123;
    @Action("updateProfile")
    void updateProfile(@FormData("profile") UserProfile profile) &#123;
        userService.update(profile);
        // Global variable will automatically update in UserHeaderWidget
    }
}</xis:raw></code></pre>
    <p>In templates, global variables are accessed with the <code>global.&lt;property&gt;</code> prefix and update reactively across all
        components:</p>
    <pre><code class="language-html"><xis:raw>&lt;!-- UserHeaderWidget.html --&gt;
&lt;header&gt;
    &lt;div&gt;Welcome &#036;&#123;global.currentUserName}!&lt;/div&gt;
    &lt;span xis:if="&#036;&#123;global.currentUserName != null}"&gt;
        Status: Logged in
    &lt;/span&gt;
&lt;/header&gt;

&lt;!-- UserProfileWidget.html --&gt;
&lt;div class="profile"&gt;
    &lt;h2&gt;Profile for &#036;&#123;global.currentUserName}&lt;/h2&gt;
    &lt;form xis:binding="profile"&gt;
        &lt;input xis:binding="displayName" value="&#036;&#123;global.currentUserName}"&gt;
        &lt;button xis:action="updateProfile"&gt;Update&lt;/button&gt;
    &lt;/form&gt;
&lt;/div&gt;</xis:raw></code></pre>

    <h6>@ClientStorage</h6>
    <p>Manages server-side state per client/session. Unlike LocalStorage and SessionStorage which store data in the browser, 
        ClientStorage keeps data on the server, making it suitable for sensitive data, larger datasets, or data that should 
        not be accessible via browser DevTools. Data persists for the duration of the client session.</p>
    <p>
        <strong>Behavior:</strong>
    </p>
    <ul>
        <li><strong>On methods:</strong> The return value is <strong>always written</strong> to server-side client storage</li>
        <li><strong>As parameter:</strong> The value is <strong>read from</strong> server-side client storage</li>
        <li><strong>Updates:</strong> Changes do not automatically trigger updates in other components. Use 
            <code>@Action(updateEventKeys = {...})</code> to notify other widgets via <code>@RefreshOnUpdateEvents</code></li>
    </ul>
    <pre><code class="language-java"><xis:raw>// Method: Writes return value to server-side client storage
@ClientStorage("selectedTab")
String getSelectedTab() &#123;
    return "dashboard"; // This value is written to client storage on server
}

// Parameter: Reads current value from server-side client storage
@ModelData
String getActiveContent(@ClientStorage("selectedTab") String tab) &#123;
    return contentService.getContentForTab(tab);
}

// Action: Updates client storage and notifies other widgets
@Action(value = "selectTab", updateEventKeys = &#123;"tab-changed"})
@ClientStorage("selectedTab") // Return value is saved to client storage
String selectTab(@ActionParameter("tab") String tab) &#123;
    return tab; // Saved to client storage, emits "tab-changed" event
}</xis:raw></code></pre>
    <p>In templates, access with the <code>clientStorage.</code> prefix:</p>
    <pre><code class="language-html"><xis:raw>&lt;nav&gt;
    &lt;button class="&#036;&#123;clientStorage.selectedTab == 'dashboard' ? 'active' : ''}"
            xis:action="selectTab"&gt;
        &lt;xis:parameter name="tab" value="dashboard"/&gt;
        Dashboard
    &lt;/button&gt;
    &lt;button class="&#036;&#123;clientStorage.selectedTab == 'profile' ? 'active' : ''}"
            xis:action="selectTab"&gt;
        &lt;xis:parameter name="tab" value="profile"/&gt;
        Profile
    &lt;/button&gt;
&lt;/nav&gt;</xis:raw></code></pre>
    <p>Other widgets can reload when client storage changes:</p>
    <pre><code class="language-java"><xis:raw>@Widget
@RefreshOnUpdateEvents("tab-changed")
class TabContentWidget &#123;
    // This widget will reload when "tab-changed" event is emitted
}</xis:raw></code></pre>

    <h6>@LocalStorage</h6>
    <p>Accesses the browser's localStorage for persistent client-side data storage. Data survives page reloads, browser
        restarts, and even computer restarts - until explicitly cleared by the user or application. Perfect for user
        preferences, settings, and long-term state.</p>
    <pre><code class="language-java"><xis:raw>// ThemeWidget.java
@Widget
class ThemeWidget &#123;
    @LocalStorage("userTheme")
    String getUserTheme() &#123;
        return "dark"; // Default value
    }

    @Action("changeTheme")
    void changeTheme(@ActionParameter("theme") String theme) &#123;
        // Will automatically save to localStorage
    }
}

// LayoutWidget.java
@Widget
class LayoutWidget &#123;
    // Can access same localStorage from different widget
    String getLayoutClass(@LocalStorage("userTheme") String theme) &#123;
        return "layout-" + theme;
    }
}</xis:raw></code></pre>
    <p>In templates, localStorage values are accessed with the <code>localStorage.&lt;property&gt;</code> prefix and update reactively
        across all components:</p>
    <pre><code class="language-html"><xis:raw>&lt;!DOCTYPE html&gt;
&lt;html xmlns:xis="https://xis.one/xsd"&gt;
&lt;body class="theme-&#036;&#123;localStorage.userTheme}"&gt;
    &lt;!-- ThemeWidget.html --&gt;
    &lt;div class="theme-selector"&gt;
        &lt;h3&gt;Choose Theme&lt;/h3&gt;
        &lt;button class="&#036;&#123;localStorage.userTheme == 'light' ? 'selected' : ''}"
                xis:action="changeTheme"&gt;
            &lt;xis:parameter name="theme" value="light"/&gt;
            Light Theme
        &lt;/button&gt;
        &lt;button class="&#036;&#123;localStorage.userTheme == 'dark' ? 'selected' : ''}"
                xis:action="changeTheme"&gt;
            &lt;xis:parameter name="theme" value="dark"/&gt;
            Dark Theme
        &lt;/button&gt;
        &lt;p&gt;Current theme: &#036;&#123;localStorage.userTheme}&lt;/p&gt;
    &lt;/div&gt;

    &lt;!-- LayoutWidget.html --&gt;
    &lt;main class="layout-&#036;&#123;localStorage.userTheme}"&gt;
        &lt;div xis:if="&#036;&#123;localStorage.userTheme == 'dark'}"&gt;
            &lt;style&gt;.content &#123; background: #333; color: white; }&lt;/style&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;This content adapts to the stored theme: &#036;&#123;localStorage.userTheme}&lt;/p&gt;
        &lt;/div&gt;
    &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;</xis:raw></code></pre>

</xis:template>
<xis:template xmlns:xis="http://www.w3.org/1999/XSL/Transform">
    <h3>${chapterHeadline}</h3>
    
    <div class="warning">
        <strong>Note on Distributed Applications:</strong> This documentation mentions micro-frontend architectures 
        and distributed widget loading. These features are planned but <strong>not yet implemented</strong> in the 
        current version of XIS. All other widget features described here are fully functional.
    </div>
    
    <p>
        Widgets are reusable components in XIS that can be embedded within pages or other widgets. They are 
        controllers annotated with <code>@Widget</code> and promote a modular, component-based architecture 
        for building complex user interfaces.
    </p>
    
    <h5>Defining a Widget</h5>
    <p>
        A widget controller is a Java class annotated with <code>@Widget</code>. By default, the widget ID 
        is the simple class name, but can be customized using the annotation parameter. Like pages, each 
        widget has a corresponding HTML template in the same package.
    </p>
    
    <pre><code>@Widget
public class UserCard {
    
    @ModelData
    public String userName() {
        return "John Doe";
    }
    
    @ModelData
    public String userEmail() {
        return "john@example.com";
    }
}</code></pre>

    <h5>Embedding Widgets</h5>
    <p>
        Widgets are embedded in pages or other widgets using widget containers. There are several ways 
        to embed a widget:
    </p>
    
    <p>
        Using the <code>&lt;xis:widget-container&gt;</code> tag with a <code>default-widget</code> attribute:
    </p>
    
    <pre><code>&lt;xis:widget-container container-id="userInfo" 
                     default-widget="UserCard"/&gt;</code></pre>

    <p>
        Using the shorthand <code>&lt;xis:widget&gt;</code> tag:
    </p>
    
    <pre><code>&lt;xis:widget name="UserCard"/&gt;</code></pre>

    <p>
        Or using the <code>xis:widget</code> attribute on any HTML element:
    </p>
    
    <pre><code>&lt;div xis:widget="UserCard"&gt;&lt;/div&gt;</code></pre>

    <h5>Dynamic Widget Updates</h5>
    <p>
        Widget containers can be dynamically updated through controller actions that return 
        <code>WidgetResponse</code> objects. This enables partial page updates without full page reloads, 
        perfect for interactive user interfaces:
    </p>
    
    <pre><code>@Action
public WidgetResponse updateUserInfo() {
    return new WidgetResponse(UpdatedUserCard.class);
}</code></pre>

    <h5>Widget Composition</h5>
    <p>
        Widgets can contain other widgets, allowing you to build complex UIs from simple, reusable building 
        blocks. This compositional approach promotes code reuse and maintains clear separation of concerns 
        across your application.
    </p>

    <h5>Using XIS Without Widgets</h5>
    <p>
        While widgets provide powerful capabilities, XIS can also be used without them by working exclusively 
        with pages. However, this approach comes with certain limitations. Without widgets, you lose the ability 
        to build distributed applications where components can be served from different servers, which is essential 
        for micro-frontend architectures. Additionally, every user interaction requires a full page reload since 
        partial page updates through <code>WidgetResponse</code> are not available. This means that even when only 
        small sections of the page need to change, the entire page must be regenerated and sent to the client, 
        which can impact performance and user experience in interactive applications.
    </p>

    <h5>Micro-Frontend Architecture with Widgets</h5>
    <p>
        One of the most powerful capabilities enabled by XIS widgets is building micro-frontend architectures. 
        Widgets can be loaded from different servers, allowing independent teams to develop, deploy, and maintain 
        their own components within a larger application. This architectural pattern is particularly valuable for 
        large organizations where different teams own different parts of the user interface.
    </p>
    <p>
        For example, one team might develop a shopping cart widget hosted on <code>shop.example.com</code>, while 
        another team maintains a user profile widget on <code>users.example.com</code>. Both widgets can be 
        seamlessly integrated into a main application, with each team deploying updates independently without 
        requiring coordination or rebuilding the entire application. This enables true organizational scalability 
        and team autonomy.
    </p>
    <p>
        The technical details of implementing distributed widget architectures, including cross-origin configuration, 
        security considerations, and deployment strategies, are covered in the advanced Micro-Frontend Architecture 
        chapter later in this documentation.
    </p>
</xis:template>

<xis:template xmlns:xis="http://www.w3.org/1999/XSL/Transform">
    <h3>${chapterHeadline}</h3>
    <p>
        XIS provides several annotations that are applied at the class level to configure controllers, define 
        application structure, and control component behavior. These annotations work on any class, not just 
        controllers, and provide framework-wide functionality.
    </p>

    <h5>@Page and @Widget</h5>
    <p>
        The fundamental annotations that define your application structure. <code>@Page</code> marks a controller 
        as a page with a specific URL path, while <code>@Widget</code> marks a controller as a reusable component.
    </p>
    <p>
        These annotations are covered in detail in the <a href="#" xis:page="PagesAndWidgets">Pages and Widgets</a> 
        section. Quick reference:
    </p>
    <pre><code>@Page("/users/list.html")
class UserListPage $​{ /* ... */ }

@Widget // ID defaults to "ProductCard"
class ProductCard $​{ /* ... */ }

@Widget("customId")
class CustomWidget $​{ /* ... */ }</code></pre>

    <h5>@WelcomePage</h5>
    <p>
        Designates a page as the default welcome page (landing page) of your application. Exactly one page in 
        your application must be annotated with <code>@WelcomePage</code>. This page is displayed when users 
        access the root URL or when no other URL mapping matches.
    </p>
    <p>
        <strong>Important:</strong> The framework will throw an <code>IllegalStateException</code> if zero or 
        multiple pages are annotated with <code>@WelcomePage</code>. There must be exactly one.
    </p>
    <pre><code>@WelcomePage
@Page("/index.html")
class HomePage $​{
    @ModelData
    String getWelcomeMessage() $​{
        return "Welcome to XIS Framework!";
    }
}</code></pre>
    <p>
        <strong>Use Cases:</strong>
    </p>
    <ul>
        <li>Landing page / home page of your application</li>
        <li>Dashboard that users see after login</li>
        <li>Default page when accessing the application root URL</li>
    </ul>

    <h5>@RefreshOnUpdateEvents</h5>
    <p>
        Registers a widget to automatically reload when specific update events are emitted by actions. This 
        annotation enables a clean publish-subscribe pattern for communication between widgets without tight 
        coupling.
    </p>
    <p>
        <strong>How it works:</strong> When an action method includes <code>@Action(updateEventKeys = $​{...})</code>, 
        XIS automatically reloads all widgets that are listening to those event keys via 
        <code>@RefreshOnUpdateEvents</code>.
    </p>
    <pre><code>// Widget that listens for events
@Widget
@RefreshOnUpdateEvents("user-data-changed")
class UserListWidget $​{
    @ModelData
    List&lt;User&gt; getUsers() $​{
        return userService.findAll();
    }
}

// Widget that emits events
@Widget
class UserFormWidget $​{
    @Action(value = "saveUser", updateEventKeys = $​{"user-data-changed"})
    void saveUser(@FormData("user") User user) $​{
        userService.save(user);
        // UserListWidget will automatically reload
    }
}

// Multiple events supported
@Widget
@RefreshOnUpdateEvents($​{"user-data-changed", "settings-updated", "theme-changed"})
class DashboardWidget $​{
    // Reloads when any of these events is emitted
}</code></pre>
    <p>
        <strong>Benefits:</strong>
    </p>
    <ul>
        <li>Decouples widgets - emitter doesn't need to know about listeners</li>
        <li>Multiple widgets can react to the same event</li>
        <li>One widget can listen to multiple events</li>
        <li>Clean separation of concerns and maintainable code</li>
    </ul>
    <p>
        See also: <a href="#" xis:page="MethodAnnotations">@Action annotation</a> for details on emitting 
        update events.
    </p>

    <h5>@Roles</h5>
    <p>
        When applied at the class level, <code>@Roles</code> enforces role-based access control for all methods 
        in the controller. Users must have one of the specified roles to access any method in the class, unless 
        overridden by method-level <code>@Roles</code> annotations.
    </p>
    <p>
        <strong>Note:</strong> Requires the <code>xis-authentication</code> dependency. See the 
        <a href="#" xis:page="Security">Security</a> section for authentication setup.
    </p>
    <pre><code>// All methods require ADMIN role
@Page("/admin/dashboard.html")
@Roles("ADMIN")
class AdminDashboard $​{
    
    @ModelData
    List&lt;User&gt; getAllUsers() $​{
        return userService.findAll(); // Requires ADMIN role
    }
    
    @Action("deleteUser")
    void deleteUser(String userId) $​{
        userService.delete(userId); // Requires ADMIN role
    }
}

// Multiple roles allowed at class level
@Widget
@Roles($​{"ADMIN", "MODERATOR"})
class ModerationWidget $​{
    // All methods accessible by ADMIN or MODERATOR
    
    @Action("approvePost")
    void approvePost(String postId) $​{
        postService.approve(postId);
    }
    
    @Action("deletePost")
    @Roles("ADMIN") // Method-level: further restricts to ADMIN only
    void deletePost(String postId) $​{
        postService.delete(postId);
    }
}</code></pre>
    <p>
        <strong>Inheritance:</strong> Method-level <code>@Roles</code> annotations do not inherit from the class 
        level. If a method has its own <code>@Roles</code>, it completely overrides the class-level roles for 
        that specific method.
    </p>
    <p>
        See also: <a href="#" xis:page="MethodAnnotations">@Roles on methods</a> for method-level access control.
    </p>

</xis:template>

<xis:template xmlns:xis="http://www.w3.org/1999/XSL/Transform">
    <h3>${chapterHeadline}</h3>
    <p>Widgets are reusable, self-contained components that can be embedded in pages or other widgets. They provide 
        encapsulation and composability, making it easy to build complex UIs from smaller, testable pieces.</p>
    
    <p>This section covers advanced widget concepts in detail. Each topic has its own dedicated chapter:</p>

    <h5>Chapter Overview</h5>
    
    <h6><a href="#" xis:page="WidgetContainers">Widget Containers</a></h6>
    <p>Learn how to define widget containers on pages, set default widgets, and pass parameters using both query 
        string and <code>&lt;xis:parameter&gt;</code> tag syntax. Understand container IDs and how multiple containers 
        work together.</p>
    
    <h6><a href="#" xis:page="WidgetParameters">Widget Parameters</a></h6>
    <p>Understand the difference between <code>@WidgetParameter</code> and <code>@ActionParameter</code>. Learn the 
        two ways to pass widget parameters (query string vs tags) and how to combine widget and action parameters 
        in the same controller.</p>
    
    <h6><a href="#" xis:page="WidgetNavigation">Widget Navigation</a></h6>
    <p>Master widget navigation through template links, action return values, and <code>WidgetResponse</code>. 
        Understand widget IDs, target containers, and the difference between <code>WidgetResponse</code> and 
        <code>PageResponse</code>. Learn about string-based widget IDs for distributed applications.</p>
    
    <h6><a href="#" xis:page="WidgetUpdateEvents">Update Events</a></h6>
    <p>Build reactive UIs where multiple widgets stay synchronized using update events. See complete working examples 
        including a shopping cart system with cart summary, notifications, and product list widgets that all update 
        automatically when items are added.</p>
    
    <h6>Widgets and Deep Linking</h6>
    <p>XIS widgets are deep-link capable through the <code>@Widget</code> annotation. You can specify a URL, 
        browser title, and target container ID to enable direct navigation to specific widget states and ensure 
        widgets load into the correct container regardless of HTML defaults.</p>
    
    <pre><code class="language-java">@Widget(id = "ProductDetails", 
       url = "/products/{productId}.html",
       title = "Product Details",
       containerId = "main")
class ProductDetailsWidget {
    @ModelData("productId")
    String getProductId(@PathVariable("productId") String productId) {
        return productId;
    }
    
    @ModelData("productName")
    String getProductName(@PathVariable("productId") String productId) {
        // Load product from database
        return "Product " + productId;
    }
}</code></pre>
    
    <p><strong>Key Deep Linking Features:</strong></p>
    <ul>
        <li><strong>url</strong> - Custom URL displayed in browser (supports path variables like <code>{productId}</code>)</li>
        <li><strong>title</strong> - Browser title/tab text when widget is active</li>
        <li><strong>containerId</strong> - Target container, overrides HTML <code>default-widget</code> attribute</li>
    </ul>
    
    <p><strong>Path Variables in Widget URLs:</strong></p>
    <p>Widgets support path variables just like pages. The page and widget URLs should have matching path variable 
        structures. For example:</p>
    
    <pre><code class="language-java">// Page defines the base URL with path variable
@Page("/products/{productId}.html")
class ProductPage { }

// Widget uses same URL structure - inherits path variables from page
@Widget(url = "/products/{productId}.html", title = "Product Details")
class ProductDetailsWidget {
    @ModelData
    String product(@PathVariable("productId") String id) {
        return loadProduct(id);
    }
}</code></pre>
    
    <p><strong>Navigating with Path Variables:</strong></p>
    <p>Widget actions can navigate to other widgets and pass path variables using <code>WidgetResponse.ofPathVariable()</code>:</p>
    
    <pre><code class="language-java">@Widget(url = "/products/{productId}.html")
class ProductDetailsWidget {
    @Action
    WidgetResponse viewCategory() {
        // Navigate to category widget with path variable
        return WidgetResponse.ofPathVariable(
            CategoryWidget.class, 
            "categoryId", 
            "electronics"
        );
    }
}

@Widget(url = "/category/{categoryId}.html", title = "Category")
class CategoryWidget {
    @ModelData
    String category(@PathVariable("categoryId") String id) {
        return loadCategory(id);
    }
}</code></pre>
    
    <p>The <code>containerId</code> is particularly powerful for micro-frontend architectures where widgets need 
        to control their own placement. When a widget specifies a <code>containerId</code>, it always loads into 
        that container, even if the page HTML has a different <code>default-widget</code> configuration. This ensures 
        consistent behavior for bookmarked URLs and shared links.</p>

    <h5>Widget Basics Recap</h5>
    <p>Before diving into the detailed chapters, here's a quick recap of widget fundamentals:</p>

    <h6>Creating a Widget</h6>
    <pre><code class="language-java">@Widget
class DashboardWidget {
    @ModelData("message")
    String getMessage() {
        return "Welcome to your dashboard!";
    }
}</code></pre>

    <h6>Widget Template</h6>
    <pre><code class="language-html">&lt;xis:template xmlns:xis="https://xis.one/xsd"&gt;
    &lt;div class="dashboard"&gt;
        &lt;h2&gt;${message}&lt;/h2&gt;
    &lt;/div&gt;
&lt;/xis:template&gt;</code></pre>

    <h6>Embedding in a Page</h6>
    <pre><code class="language-html">&lt;xis:widget-container container-id="main" default-widget="DashboardWidget"&gt;
&lt;/xis:widget-container&gt;</code></pre>

    <p>For basic widget concepts like the <code>@Widget</code> annotation and simple usage, see 
        <a href="#" xis:page="PagesAndWidgets">Pages and Widgets</a>.</p>

</xis:template>
<xis:template xmlns:xis="http://www.w3.org/1999/XSL/Transform">
    <h3>${chapterHeadline}</h3>

    <p>
        The <code>@Roles</code> annotation enables role-based access control in XIS applications.
        It can be applied to controller classes and methods.
    </p>

    <div class="info-box">
        <strong>Scope:</strong> <code>@Roles</code> can be applied to controller classes, methods, and parameter classes (DTOs).
        The annotation supports <code>ElementType.TYPE</code> and <code>ElementType.METHOD</code>.
    </div>

    <h4>Usage on Controller Classes</h4>
    <p>
        When <code>@Roles</code> is used on a controller class, the role restriction
        applies to all methods of the controller:
    </p>

    <pre><code>@Page("/admin/users.html")
@Roles({"ADMIN", "USER_MANAGER"})
public class UserManagementPage {
    
    @Action
    void deleteUser(@Parameter("userId") String userId) {
        // Only for ADMIN or USER_MANAGER
    }
    
    @Action
    void editUser(@Parameter("userId") String userId) {
        // Only for ADMIN or USER_MANAGER
    }
}</code></pre>

    <h4>Usage on Methods</h4>
    <p>
        For finer control, <code>@Roles</code> can be used on individual methods.
        Method-level roles are combined with class-level roles using AND logic - all roles must be satisfied:
    </p>

    <pre><code>@Page("/products.html")
@Roles("USER")
public class ProductPage {
    
    @ModelData
    List&lt;Product&gt; products() {
        // Available for all USER
        return productService.findAll();
    }
    
    @Action
    @Roles("ADMIN")
    void deleteProduct(@Parameter("productId") String productId) {
        // Requires BOTH USER (from class) AND ADMIN (from method)
        productService.delete(productId);
    }
}</code></pre>

    <h4>Combining Class and Method Roles (AND Logic)</h4>
    <p>
        When both class and method have <code>@Roles</code>, the user must have <strong>all</strong> roles from both annotations:
    </p>

    <pre><code>@Page("/admin.html")
@Roles({"USER", "VERIFIED"})
public class AdminPage {
    
    @Action
    @Roles("ADMIN")
    void deleteUser() {
        // Requires: USER AND VERIFIED AND ADMIN
    }
    
    @Action
    @Roles({"MODERATOR", "SUPPORT"})
    void banUser() {
        // Requires: USER AND VERIFIED AND (MODERATOR OR SUPPORT)
    }
}</code></pre>

    <h4>Usage on Parameter Classes (DTOs)</h4>
    <p>
        Parameter classes (DTOs) can also be annotated with <code>@Roles</code>. These roles are added to the 
        requirements using AND logic:
    <h4>Best Practices</h4>
    <ul>
        <li>Use descriptive role names (e.g., <code>PRODUCT_EDITOR</code> instead of <code>ROLE_3</code>)</li>
        <li>Define base roles at class level (e.g., <code>USER</code>, <code>VERIFIED</code>)</li>
        <li>Add method-level roles for additional restrictions (e.g., <code>ADMIN</code>)</li>
        <li>Use DTO-level roles for data-specific permissions (e.g., <code>DATA_EDITOR</code>)</li>
        <li>Use multiple roles within a level for alternative access: <code>@Roles({"ADMIN", "MODERATOR"})</code></li>
        <li>Remember the hierarchy: (Controller roles) AND (Method roles) AND (Parameter roles)</li>
        <li>Combine <code>@Roles</code> with <code>xis-authentication</code> for complete security</li>
    </ul>

@Page("/products.html")
@Roles("USER")
public class ProductPage {
    
    @Action
    @FormData("product")
    void updateProduct(ProductUpdateDto dto) {
        // Requires: USER (from class) AND DATA_EDITOR (from DTO)
    }
    
    @Action
    @Roles("ADMIN")
    @FormData("product")
    void adminUpdate(ProductUpdateDto dto) {
        // Requires: USER (from class) AND ADMIN (from method) AND DATA_EDITOR (from DTO)
    }
}</code></pre>

    <p>
        This is useful when certain data structures require additional privileges regardless of where they're used.
    </p>

    <h4>Multiple Roles (OR Logic)</h4>
    <p>
        When multiple roles are specified, any one of them is sufficient (OR logic):
    </p>
    <h4>Best Practices</h4>
    <ul>
        <li>Use descriptive role names (e.g., <code>PRODUCT_EDITOR</code> instead of <code>ROLE_3</code>)</li>
        <li>Define base roles at class level (e.g., <code>USER</code>, <code>VERIFIED</code>)</li>
        <li>Add method-level roles for additional restrictions (e.g., <code>ADMIN</code>)</li>
        <li>Use DTO-level roles for data-specific permissions (e.g., <code>DATA_EDITOR</code>)</li>
        <li>Use multiple roles within a level for alternative access: <code>@Roles({"ADMIN", "MODERATOR"})</code></li>
        <li>Remember the hierarchy: (Controller roles) AND (Method roles) AND (Parameter roles)</li>
        <li>Combine <code>@Roles</code> with <code>xis-authentication</code> for complete security</li>
    </ul>
    <h4>Behavior without Authentication</h4>
    <p>
        The behavior on role violations depends on whether the <code>xis-authentication</code> module
        is used:
    </p>

    <ul>
        <li>
            <strong>Without xis-authentication:</strong> An exception is thrown on missing access
        </li>
        <li>
            <strong>With xis-authentication:</strong> The user is automatically redirected to the login page
        </li>
    </ul>

    <h4>Best Practices</h4>
    <ul>
        <li>Use descriptive role names (e.g., <code>PRODUCT_EDITOR</code> instead of <code>ROLE_3</code>)</li>
        <li>Define roles at class level for general access restrictions</li>
        <li>Override with method-level roles for specific operations</li>
        <li>Combine <code>@Roles</code> with <code>xis-authentication</code> for complete security</li>
    </ul>

    <div class="info-box">
        <strong>Note:</strong> Role management and validation is handled by the authentication system.
        See next chapter <em>XIS Authentication</em> for details on token creation and role assignment.
    </div>

</xis:template>
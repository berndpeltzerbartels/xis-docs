<xis:template xmlns:xis="http://www.w3.org/1999/XSL/Transform">
    <h3>${chapterHeadline}</h3>

    <p>
        The <code>@Roles</code> annotation enables role-based access control in XIS applications.
        It can be applied to controller classes and methods.
    </p>

    <div class="info-box">
        <strong>Scope:</strong> <code>@Roles</code> can be applied to controller classes, methods, and parameter classes (DTOs).
        The annotation supports <code>ElementType.TYPE</code> and <code>ElementType.METHOD</code>.
    </div>

    <h4>Role Logic Overview</h4>
    <p>
        Understanding how roles are combined:
    </p>
    <ul>
        <li><strong>Within one annotation</strong> (<code>@Roles({"ADMIN", "MODERATOR"})</code>): <strong>OR</strong> logic - user needs at least one of these roles</li>
        <li><strong>Between levels</strong> (Controller + Method + Parameter): <strong>AND</strong> logic - all non-empty levels must be satisfied</li>
        <li><strong>Empty levels are ignored</strong>: If a level has no <code>@Roles</code>, no check is performed at that level</li>
    </ul>

    <h4>Annotation Scenarios</h4>
    <p>Different combinations of class and method annotations:</p>
    <ul>
        <li><strong>Only class annotated:</strong> All methods inherit the class roles</li>
        <li><strong>Only method annotated:</strong> Only that method's roles are checked (no class restriction)</li>
        <li><strong>Both annotated:</strong> User must satisfy both levels (AND logic between levels)</li>
        <li><strong>Neither annotated:</strong> No role restriction</li>
    </ul>

    <h4>Usage on Controller Classes</h4>
    <p>
        When <code>@Roles</code> is used on a controller class, the role restriction
        applies to all methods of the controller. Multiple roles within one annotation use OR logic:
    </p>

    <pre><code>@Page("/admin/users.html")
@Roles({"ADMIN", "USER_MANAGER"})  // User needs ADMIN OR USER_MANAGER
public class UserManagementPage {
    
    @Action
    void deleteUser(@Parameter("userId") String userId) {
        // Accessible for ADMIN OR USER_MANAGER
    }Methods can have their own <code>@Roles</code> annotation. The behavior depends on whether the class is also annotated:
    </p>

    <pre><code>// Class WITH roles - methods inherit or add requirements
@Page("/products.html")
@Roles("USER")
public class ProductPage {
    
    @ModelData
    List&lt;Product&gt; products() {
        // No method-level @Roles - inherits class requirement: USER
        return productService.findAll();
    }
    
    @Action
    @Roles("ADMIN")
    void deleteProduct(@Parameter("productId") String productId) {
        // Has method-level @Roles - requires: USER (class) AND ADMIN (method)
        productService.delete(productId);
    }
}

// Class WITHOUT roles - only method roles apply
@Page("/public/blog.html")
public class PublicBlogPage {
    
    @ModelData
    List&lt;Post&gt; posts() {
        // No restrictions - accessible to everyone
        return blogService.findAll();
    }
    
    @Action
    @Roles("ADMIN")
    void deletePost(@Parameter("postId") String postId) {
        // Only method-level @Roles - requires: ADMIN only
        blogService.delete(pos
        // Accessible for all users with USER role
        return productService.findAll();
    }
    
    @Action
    @Roles("ADMIN")
    void deleteProduct(@Parameter("productId") String productId) {
        // Requires: USER (from class) AND ADMIN (from method)
        // User must have BOTH roles
        productService.delete(productId);
    }
}</code></pre>

    <h4>Combining Class and Method Roles</h4>
    <p>
        When both class and method have <code>@Roles</code>, different levels are combined with AND, 
        while roles within one level use OR:
    </p>

    <pre><code>@Page("/content.html")
@Roles({"EDITOR", "AUTHOR"})  // User needs EDITOR OR AUTHOR
public class ContentPage {
    
    @ModelData
    List&lt;Article&gt; articles() {
        // Accessible for EDITOR OR AUTHOR
        return articleService.findAll();
    }
    
    @Action
    @Roles("ADMIN")
    void deleteArticle(@Parameter("id") String id) {
        // Requires: (EDITOR OR AUTHOR) AND ADMIN
        // User must have ADMIN + at least one of (EDITOR or AUTHOR)
        articleService.delete(id);
    }
    
    @Action
    @Roles({"MODERATOR", "SUPERVISOR"})
    void approveArticle(@Parameter("id") String id) {
        // Requires: (EDITOR OR AUTHOR) AND (MODERATOR OR SUPERVISOR)
        // User needs at least one from each level
        articleService.approve(id);
    }
}</code></pre>

    <h4>Usage on Parameter Classes (DTOs)</h4>
    <p>
        Parameter classes (DTOs) can also be annotated with <code>@Roles</code>. These roles are added as a third level 
        using AND logic between levels:
    </p>

    <pre><code>@Roles({"DATA_EDITOR", "CONTENT_MANAGER"})
public class ProductUpdateDto {
    private String name;
    private BigDecimal price;
}

@Page("/products.html")
@Roles("USER")
public class ProductPage {
    
    @Action
    @FormData("product")
    void updateProduct(ProductUpdateDto dto) {
        // Requires: (USER) AND (DATA_EDITOR OR CONTENT_MANAGER)
    }
    
    @Action
    @Roles({"ADMIN", "SUPERVISOR"})
    @FormData("product")
    void adminUpdate(ProductUpdateDto dto) {
        // Requires: (USER) AND (ADMIN OR SUPERVISOR) AND (DATA_EDITOR OR CONTENT_MANAGER)
    }
}</code></pre>

    <p>
        This is useful when certain data structures require additional privileges regardless of where they're used.
    </p>

    <h4>Behavior without Authentication</h4>
    <p>
        The behavior on role violations depends on whether the <code>xis-authentication</code> module
        is used:
    </p>

    <ul>
        <li>
            <strong>Without xis-authentication:</strong> An exception is thrown on missing access
        </li>
        <li>
            <strong>With xis-authentication:</strong> The user is automatically redirected to the login page
        </li>
    </ul>

    <h4>Best Practices</h4>
    <ul>
        <li><strong>Descriptive names:</strong> Use <code>PRODUCT_EDITOR</code> instead of <code>ROLE_3</code></li>
        <li><strong>Multiple alternatives:</strong> Use <code>@Roles({"ADMIN", "MODERATOR"})</code> for OR logic within one level</li>
        <li><strong>Class-level base access:</strong> Define general access roles at controller level (e.g., <code>USER</code>)</li>
        <li><strong>Method-level restrictions:</strong> Add additional requirements for sensitive operations (e.g., <code>ADMIN</code>)</li>
        <li><strong>DTO-level permissions:</strong> Protect sensitive data structures regardless of context</li>
        <li><strong>Remember the logic:</strong> Within annotation = OR, between levels = AND</li>
        <li><strong>Full security:</strong> Combine with <code>xis-authentication</code> for login/logout functionality</li>
    </ul>

    <div class="info-box">
        <strong>Note:</strong> Role management and validation is handled by the authentication system.
        See next chapter <em>XIS Authentication</em> for details on token creation and role assignment.
    </div>

</xis:template>
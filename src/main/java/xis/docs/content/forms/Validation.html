<xis:template xmlns:xis="http://www.w3.org/1999/XSL/Transform">
    <h3>${chapterHeadline}</h3>
    <p>XIS provides its own validation framework with built-in annotations for declarative form validation.</p>

    <h5>Basic Validation</h5>
    <p>Add XIS validation annotations to your form object (works with records and classes):</p>
    <xis:raw>
        <pre><code>
public record UserForm(
    @Mandatory  // Validates not null AND not empty/blank
    @MinLength(2)
    String firstName,
    
    @Mandatory
    @Email
    String email,
    
    @Mandatory
    Integer age  // Use Integer, not int, to allow null checking
) {}
</code></pre>
        <p><strong>Note:</strong> <code>@Mandatory</code> combines null and empty checks in a single annotation.
            Validation messages are looked up from message properties files using keys.</p>
    </xis:raw>

    <h5>Automatic Validation</h5>
    <p>Form data is automatically validated when submitted. Controllers are stateless - form data is passed as action
        parameters:</p>
    <xis:raw>
        <pre><code>@Widget
class UserFormWidget {
    
    @Action
    void saveUser(@FormData("user") UserForm userForm) {
        // This only executes if validation passes
        userService.save(userForm);
    }
}</code></pre>
        <p>If validation fails, the action method is <strong>not executed</strong> and validation errors are
            automatically available in the template.</p>
    </xis:raw>

    <h5>Displaying Validation Errors</h5>

    <h6>Field-Level Error Messages</h6>
    <p>Use <code>xis:message-for</code> to display validation errors for specific fields:</p>
    <xis:raw>
        <pre><code>&lt;form xis:binding="user"&gt;
    &lt;div&gt;
        &lt;label&gt;First Name&lt;/label&gt;
        &lt;input type="text" xis:binding="firstName"/&gt;
        &lt;div xis:message-for="firstName"&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
        &lt;label&gt;Email&lt;/label&gt;
        &lt;input type="email" xis:binding="email"/&gt;
        &lt;div xis:message-for="email"&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;button type="submit" xis:action="saveUser"&gt;Save&lt;/button&gt;
&lt;/form&gt;</code></pre>
        <p>The error message is automatically inserted into the element with <code>xis:message-for</code>.
            The binding name matches the field binding (e.g., "firstName", "email").</p>
    </xis:raw>

    <h6>Global Error Messages</h6>
    <p>Display all validation errors in a single location. XIS provides two approaches:</p>
    
    <p><strong>Method 1: Using &lt;xis:global-messages&gt; (Recommended)</strong></p>
    <p>Use the <code>&lt;xis:global-messages&gt;</code> tag for automatic rendering of global validation errors:</p>
    <xis:raw>
        <pre><code>&lt;form xis:binding="user"&gt;
    &lt;!-- Automatically renders global validation errors --&gt;
    &lt;xis:global-messages/&gt;
    
    &lt;input type="text" xis:binding="firstName"/&gt;
    &lt;input type="email" xis:binding="email"/&gt;
    &lt;button type="submit" xis:action="saveUser"&gt;Save&lt;/button&gt;
&lt;/form&gt;</code></pre>
        <p>XIS automatically generates a <code>&lt;ul class="error"&gt;</code> with <code>&lt;li class="error"&gt;</code> 
            elements for each validation error. Style these classes in your CSS as needed.</p>
    </xis:raw>
    
    <p><strong>Method 2: Manual rendering with xis:foreach</strong></p>
    <p>For custom layouts, manually iterate over <code>validation.globalMessages</code>:</p>
    <xis:raw>
        <pre><code>&lt;form xis:binding="user"&gt;
    &lt;!-- Custom global error summary --&gt;
    &lt;ul class="error-summary" xis:if="${notEmpty(validation.globalMessages)}"&gt;
        &lt;li xis:foreach="message:${validation.globalMessages}"&gt;${message}&lt;/li&gt;
    &lt;/ul&gt;
    
    &lt;input type="text" xis:binding="firstName"/&gt;
    &lt;input type="email" xis:binding="email"/&gt;
    &lt;button type="submit" xis:action="saveUser"&gt;Save&lt;/button&gt;
&lt;/form&gt;</code></pre>
        <p>This approach gives you full control over the error display markup and styling.</p>
    </xis:raw>

    <h6>Error Styling with CSS Classes</h6>
    <p>XIS automatically adds the <code>error</code> CSS class to form input elements with validation errors.
        For custom styling on elements, use <code>xis:error-class</code> or apply inline styles with <code>xis:error-style</code>:
    </p>
    <xis:raw>
        <pre><code>&lt;form xis:binding="user"&gt;
    &lt;div&gt;
        &lt;!-- Label gets error class when field has error --&gt;
        &lt;label xis:binding="firstName" xis:error-class="error-label"&gt;First Name&lt;/label&gt;
        &lt;input type="text" xis:binding="firstName"/&gt;
        &lt;!-- Input automatically gets 'error' class on validation error --&gt;
        &lt;div xis:message-for="firstName"&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
        &lt;label&gt;Last Name&lt;/label&gt;
        &lt;!-- Input with custom inline error styling --&gt;
        &lt;input type="text" xis:binding="lastName" 
               xis:error-class="error"/&gt;
        &lt;div xis:message-for="lastName"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/form&gt;</code></pre>
    </xis:raw>

    <p>Style the error states with CSS:</p>
    <xis:raw>
        <pre><code>&lt;style&gt;
    /* Automatically applied to input elements */
    input.error {
        border-color: red;
        background-color: #fff0f0;
    }
    
    /* Applied via xis:error-class */
    .error-label {
        color: red;
        font-weight: bold;
    }
    
    /* Style for error messages */
    div[xis\\:message-for] {
        color: red;
        font-size: 0.9em;
    }
&lt;/style&gt;</code></pre>
    </xis:raw>

    <h5>Common Validation Annotations</h5>
    <p>XIS provides built-in validation annotations:</p>
    <xis:raw>
        <table border="1" style="border-collapse:collapse;">
            <tr>
                <th>Annotation</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
            <tr>
                <td><code>@Mandatory</code></td>
                <td>Value must not be null, empty, or whitespace</td>
                <td><code>@Mandatory private String name;</code></td>
            </tr>
            <tr>
                <td><code>@Email</code></td>
                <td>String must be valid email format</td>
                <td><code>@Email private String email;</code></td>
            </tr>
            <tr>
                <td><code>@MinLength</code></td>
                <td>String minimum length</td>
                <td><code>@MinLength(8) private String password;</code></td>
            </tr>
        </table>
        <p><strong>Note:</strong> Examples like <code>@Iban</code> and <code>@MoneyAmount</code> in this documentation
            are custom validation annotations that you create yourself (see Custom Validation Annotations section
            below).</p>
    </xis:raw>

    <h5>@LabelKey - Context-Specific Error Messages</h5>
    <p>The <code>@LabelKey</code> annotation enables reusable validation annotations by providing context-specific field
        labels in error messages.</p>

    <p><strong>The Problem:</strong> Generic validation annotations like <code>@MoneyAmount</code> can be used in many
        different contexts.
        Without <code>@LabelKey</code>, you'd need to write a generic error message that works for all use cases.
        With <code>@LabelKey</code>, each field can have its own meaningful label in the error message.</p>

    <h6>Example: Custom @MoneyAmount Annotation</h6>
    <p>First, define the custom validation annotation (this is an example you would create):</p>
    <xis:raw>
        <pre><code>import java.lang.annotation.*;
import one.xis.validation.Validate;

@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Validate(validatorClass = MoneyAmountValidator.class, messageKey = "validation.moneyAmount.invalid")
public @interface MoneyAmount {
    double maxValue() default Double.MAX_VALUE;
}</code></pre>
    </xis:raw>

    <h6>Without @LabelKey - Generic Messages</h6>
    <p>Without <code>@LabelKey</code>, you must write generic error messages that work for all use cases of the
        validator:</p>
    <xis:raw>
        <pre><code>public class ProductForm {
    
    @Mandatory
    @MoneyAmount(maxValue = 1000000)
    private String minimumSalePrice;
    
    @Mandatory
    @MoneyAmount(maxValue = 50000)
    private String offerPrice;
}</code></pre>
        <pre><code># messages.properties - Generic message must work for all fields
validation.moneyAmount.invalid=The amount is not a valid monetary value
validation.moneyAmount.exceeds=The amount exceeds the maximum value of ${maxValue}</code></pre>
        <p><strong>Problem:</strong> Error messages lack field-specific context:</p>
        <ul>
            <li>"The amount is not a valid monetary value" - Which amount?</li>
            <li>"The amount exceeds the maximum value of 1000000" - Which field?</li>
        </ul>
    </xis:raw>

    <h6>With @LabelKey - Context-Specific Messages</h6>
    <p>With <code>@LabelKey</code>, each field can have its own meaningful label in error messages:</p>
    <xis:raw>
        <pre><code>public class ProductForm {
    
    @Mandatory
    @MoneyAmount(maxValue = 1000000)
    @LabelKey("minimumSalePrice")
    private String minimumSalePrice;
    
    @Mandatory
    @MoneyAmount(maxValue = 50000)
    @LabelKey("offerPrice")
    private String offerPrice;
    
    @Mandatory
    @MoneyAmount(maxValue = 100000)
    @LabelKey("taxAmount")
    private String taxAmount;
}</code></pre>
    </xis:raw>

    <h6>Properties File Setup</h6>
    <p>Define field-specific labels using the keys from <code>@LabelKey</code>:</p>
    <xis:raw>
        <pre><code># messages.properties
# Field labels - specific to each context
minimumSalePrice=Minimum Sale Price
offerPrice=Offer Price
taxAmount=Tax Amount

# Validation message template with ${label} placeholder
validation.moneyAmount.invalid=The ${label} is not a valid monetary value
validation.moneyAmount.exceeds=The ${label} exceeds the maximum value of ${maxValue}</code></pre>
    </xis:raw>

    <h6>Result</h6>
    <p>The validation framework replaces <code>${label}</code> with the field-specific label:</p>
    <ul>
        <li><code>minimumSalePrice</code> error: "The Minimum Sale Price is not a valid monetary value"</li>
        <li><code>offerPrice</code> error: "The Offer Price exceeds the maximum value of 50000"</li>
        <li><code>taxAmount</code> error: "The Tax Amount is not a valid monetary value"</li>
    </ul>

    <h6>Key Benefits</h6>
    <ul>
        <li><strong>Reusable validators</strong> - Same validation logic, different contexts</li>
        <li><strong>Meaningful messages</strong> - Field-specific labels in error messages</li>
        <li><strong>Internationalization</strong> - Labels defined per locale in properties files</li>
        <li><strong>Custom variables</strong> - Validators can add additional variables (e.g., <code>${max}</code>,
            <code>${country}</code>)
        </li>
    </ul>

    <h5>Nested Object Validation</h5>
    <p>Nested objects are automatically validated:</p>
    <xis:raw>
        <pre><code>public class OrderForm {
    
    @Mandatory
    private CustomerInfo customer;
    
    @Mandatory
    private AddressInfo shippingAddress;
}

public class CustomerInfo {
    
    @Mandatory
    private String name;
    
    @Email
    private String email;
}</code></pre>
        <p>Errors for nested fields use dot notation: <code>${errors['order.customer.name']}</code></p>
    </xis:raw>

    <h5>Validation Messages</h5>
    <p>XIS uses message keys for validation error messages, enabling internationalization and customization.</p>

    <h6>Message Properties Files</h6>
    <xis:raw>
        <p>XIS provides default validation messages in:</p>
        <ul>
            <li><code>default-messages.properties</code> - Default English messages</li>
            <li><code>default-messages_de.properties</code> - German messages</li>
            <li><code>default-messages_en.properties</code> - English messages</li>
        </ul>
        <p>Override these messages by creating your own files:</p>
        <ul>
            <li><code>messages.properties</code> - Your default messages</li>
            <li><code>messages_de.properties</code> - Your German messages</li>
            <li><code>messages_en.properties</code> - Your English messages</li>
        </ul>
        <p><strong>Example messages.properties:</strong></p>
        <pre><code># XIS validation messages
validation.mandatory.notNull=Required field
validation.email.invalid=Invalid email address
validation.minLength.tooShort=Minimum length is {min} characters

# Custom validation messages with ${label} placeholder
validation.iban.invalid=The provided ${label} is not a valid IBAN
validation.iban.checksum=Invalid checksum for ${label}
validation.phone.format=Invalid phone number format for ${label} in {country}</code></pre>
    </xis:raw>

    <h5>Custom Validation Annotations</h5>
    <p>Create custom validation annotations for reusable validation logic with access to <code>UserContext</code> for
        locale-aware validation.</p>

    <h6>Define the Annotation</h6>
    <xis:raw>
        <pre><code>import java.lang.annotation.*;
import one.xis.validation.Validate;

@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Validate(validatorClass = IbanValidator.class, messageKey = "validation.iban.invalid")
public @interface Iban {
}</code></pre>
        <p><strong>Message Properties Example:</strong></p>
        <pre><code># messages.properties
validation.iban.invalid=The provided ${label} is not a valid IBAN
validation.iban.checksum=Invalid checksum for ${label}

# Labels for different IBAN fields using @LabelKey
accountNumber=Account Number
paymentAccount=Payment Account
beneficiaryAccount=Beneficiary Account</code></pre>
    </xis:raw>

    <h6>ValidatorException and Message Parameters</h6>
    <p>When validation fails, throw a <code>ValidatorException</code>. You can optionally provide message parameters
        that will be available as variables in your error message templates:</p>
    <xis:raw>
        <pre><code>// ValidatorException structure
@Getter
public class ValidatorException extends Exception {
    private final Map&lt;String, Object&gt; messageParameters = new HashMap&lt;&gt;();
    
    public ValidatorException() {
        super();
    }
    
    public ValidatorException(Map&lt;String, Object&gt; messageParameters) {
        super();
        this.messageParameters.putAll(messageParameters);
    }
}</code></pre>
        <p><strong>Using Message Parameters:</strong></p>
        <pre><code>// In validator
if (iban.length() != expectedLength) {
    throw new ValidatorException(Map.of(
        "country", countryCode,
        "expectedLength", expectedLength,
        "actualLength", iban.length()
    ));
}</code></pre>
        <pre><code># In messages.properties
validation.iban.length=The ${label} for ${country} must be ${expectedLength} characters long (current: ${actualLength})</code></pre>
        <p>Message parameters can use <code>${parameterName}</code> syntax in property files, just like the <code>${label}</code>
            placeholder.</p>
    </xis:raw>

    <h6>Implement the Validator</h6>
    <xis:raw>
        <pre><code>import one.xis.context.UserContext;
import one.xis.validation.Validator;
import one.xis.validation.ValidatorException;
import java.lang.reflect.AnnotatedElement;
import java.util.Map;

public class IbanValidator implements Validator&lt;String&gt; {
    
    @Override
    public void validate(String value, AnnotatedElement annotatedElement, UserContext userContext) 
            throws ValidatorException {
        // Null values are valid unless @Mandatory is also used
        if (value == null || value.isEmpty()) {
            return;
        }
        
        // Remove spaces and convert to uppercase
        String iban = value.replaceAll("\\s", "").toUpperCase();
        
        // Basic length check (15-34 characters)
        if (iban.length() &lt; 15 || iban.length() &gt; 34) {            // The error message displayed to users is defined by the @Validate annotation's messageKey            throw new ValidatorException();
        }
        
        // Country-specific validation using UserContext (only locale and zoneId are relevant)
        String countryCode = iban.substring(0, 2);
        
        // Example: Validate length based on country
        if ("DE".equals(countryCode) && iban.length() != 22) {
            throw new ValidatorException(Map.of("country", "DE", "expectedLength", 22));
        }
        if ("AT".equals(countryCode) && iban.length() != 20) {
            throw new ValidatorException(Map.of("country", "AT", "expectedLength", 20));
        }
        
        // Perform checksum validation (mod 97)
        if (!validateChecksum(iban)) {
            throw new ValidatorException();
        }
    }
    
    private boolean validateChecksum(String iban) {
        // Move first 4 characters to end
        String rearranged = iban.substring(4) + iban.substring(0, 4);
        
        // Replace letters with numbers (A=10, B=11, ..., Z=35)
        StringBuilder numeric = new StringBuilder();
        for (char c : rearranged.toCharArray()) {
            if (Character.isDigit(c)) {
                numeric.append(c);
            } else {
                numeric.append(c - 'A' + 10);
            }
        }
        
        // Calculate mod 97
        return mod97(numeric.toString()) == 1;
    }
    
    private int mod97(String number) {
        int result = 0;
        for (char digit : number.toCharArray()) {
            result = (result * 10 + (digit - '0')) % 97;
        }
        return result;
    }
}</code></pre>
    </xis:raw>

    <h6>Usage in Form</h6>
    <xis:raw>
        <pre><code>public class PaymentForm {
    
    @Mandatory
    @Iban
    @LabelKey("accountNumber")
    private String iban;
    
    @Mandatory
    @Iban
    @LabelKey("paymentAccount")
    private String secondaryAccount;
    
    @Mandatory
    private String accountHolder;
}</code></pre>
        <p><strong>Important:</strong> Without <code>@Mandatory</code>, a null value would be considered valid.
            The <code>@Iban</code> validator only validates non-null values.</p>
        <p><strong>Error Messages:</strong></p>
        <ul>
            <li><code>iban</code> error: "The provided Account Number is not a valid IBAN"</li>
            <li><code>secondaryAccount</code> error: "The provided Payment Account is not a valid IBAN"</li>
        </ul>
        <p><strong>Template:</strong></p>
        <pre><code>&lt;form xis:binding="payment"&gt;
    &lt;div&gt;
        &lt;label&gt;IBAN&lt;/label&gt;
        &lt;input type="text" xis:binding="iban" value="${payment.iban}"/&gt;
        &lt;div xis:message-for="iban"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;button type="submit" xis:action="savePayment"&gt;Save&lt;/button&gt;
&lt;/form&gt;</code></pre>
    </xis:raw>

    <h6>Usage on Action Parameters</h6>
    <xis:raw>
        <pre><code>@Action
void addPaymentMethod(
    @ActionParameter("iban") 
    @Iban 
    String iban
) {
    paymentService.addAccount(iban);
}</code></pre>
    </xis:raw>

    <h5>@Mandatory - Special Null Handling</h5>
    <p><code>@Mandatory</code> is a XIS-specific annotation that changes null-value behavior:</p>
    <xis:raw>
        <ul>
            <li><strong>Without @Mandatory:</strong> If a value is null, other validators are NOT executed (no error)
            </li>
            <li><strong>With @Mandatory:</strong> Null values cause a validation error</li>
            <li><strong>Includes:</strong> Validates not null, not empty, and not blank (whitespace)</li>
        </ul>
        <pre><code>// Without @Mandatory: null is valid, but if provided must be valid email
@Email
private String email;

// With @Mandatory: null causes error, AND if provided must be valid email
@Mandatory
@Email
private String email;</code></pre>
        <p><code>@Mandatory</code> is a XIS-specific annotation that validates not null, not empty, and not blank
            (whitespace only).</p>
    </xis:raw>

    <h5>UserContext in Validators</h5>
    <p>The <code>UserContext</code> interface provides access to user-specific information. For validation, the most
        relevant methods are:</p>
    <xis:raw>
        <ul>
            <li><strong>userContext.getLocale():</strong> User's locale for locale-specific validation and error
                messages
            </li>
            <li><strong>userContext.getZoneId():</strong> User's time zone for date/time validation</li>
        </ul>
        <p>Additional UserContext methods (getClientId(), getUserId(), getRoles(), isAuthenticated()) are available but
            typically not used in validators.</p>
        <p><strong>Validator Instantiation:</strong> Validators can be registered as Spring/Micronaut components using
            <code>@Component</code> or similar.
            If not found in the application context, XIS creates a new instance for each validation.</p>
    </xis:raw>

    <h6>Example: Locale-Specific Phone Validation</h6>
    <xis:raw>
        <pre><code>import java.lang.annotation.*;
import one.xis.validation.Validate;

@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Validate(validatorClass = PhoneNumberValidator.class, messageKey = "validation.phone.format")
public @interface PhoneNumber {
}</code></pre>
        <pre><code>public class PhoneNumberValidator implements Validator&lt;String&gt; {
    
    @Override
    public void validate(String value, AnnotatedElement annotatedElement, UserContext userContext) 
            throws ValidatorException {
        if (value == null || value.isEmpty()) {
            return;
        }
        
        // Use locale to determine phone format
        String country = userContext.getLocale().getCountry();
        
        boolean valid = switch (country) {
            case "DE" -&gt; value.matches("^\\\\+49[1-9]\\\\d{1,14}$");
            case "AT" -&gt; value.matches("^\\\\+43[1-9]\\\\d{1,13}$");
            case "US" -&gt; value.matches("^\\\\+1[2-9]\\\\d{9}$");
            default -&gt; value.matches("^\\\\+[1-9]\\\\d{1,14}$"); // Generic
        };
        
        if (!valid) {
            throw new ValidatorException(Map.of("country", country));
        }
    }
}</code></pre>
    </xis:raw>

    <h5>Validating Complex Objects</h5>
    <p>Custom validators can validate entire objects, not just single values:</p>
    <xis:raw>
        <pre><code>import java.lang.annotation.*;
import one.xis.validation.Validate;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Validate(validatorClass = DateRangeValidator.class, messageKey = "validation.daterange.invalid")
public @interface ValidDateRange {
}</code></pre>
        <pre><code>public class DateRangeValidator implements Validator&lt;EventForm&gt; {
    
    @Override
    public void validate(EventForm form, AnnotatedElement annotatedElement, UserContext userContext) 
            throws ValidatorException {
        if (form.getStartDate() == null || form.getEndDate() == null) {
            return;
        }
        if (!form.getEndDate().isAfter(form.getStartDate())) {
            throw new ValidatorException();
        }
    }
}</code></pre>
        <pre><code>// Usage on class level
@ValidDateRange
public class EventForm {
    private LocalDate startDate;
    private LocalDate endDate;
}</code></pre>
    </xis:raw>

    <div class="warning">
        <strong>Security:</strong> Always validate on the server side. Client-side validation (HTML5 attributes)
        provides user experience improvements but can be bypassed. XIS validation happens server-side and is
        security-safe.
    </div>
</xis:template>